<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<!-- Created by htmlize-1.57 in css mode. -->
<html>
  <head>
    <title>euler100.lisp</title>

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fontsource/unifont@5.2.5/index.min.css">
    <style type="text/css">
    <!--
      pre {
        font-family: "Unifont", monospace;
      }
    -->
    </style>
    <style type="text/css">
    <!--
      body {
        color: #DADADA;
        background-color: #171717;
      }
      .builtin {
        /* font-lock-builtin-face */
        color: #F6F6F6;
      }
      .comment {
        /* font-lock-comment-face */
        color: #C3C3C3;
      }
      .comment-delimiter {
        /* font-lock-comment-delimiter-face */
        color: #3C3C3C;
      }
      .constant {
        /* font-lock-constant-face */
        color: #E8E8E8;
      }
      .doc {
        /* font-lock-doc-face */
        color: #C3C3C3;
      }
      .function-name {
        /* font-lock-function-name-face */
        color: #DADADA;
      }
      .keyword {
        /* font-lock-keyword-face */
        color: #F1F1F1;
      }
      .string {
        /* font-lock-string-face */
        color: #9E9E9E;
      }
      .type {
        /* font-lock-type-face */
        color: #616161;
        font-style: italic;
      }
      .variable-name {
        /* font-lock-variable-name-face */
        color: #C3C3C3;
      }
      .warning {
        /* font-lock-warning-face */
        color: #E8E8E8;
        background-color: #3C3C3C;
        font-weight: bold;
      }

      a {
        color: inherit;
        background-color: inherit;
        font: inherit;
        text-decoration: inherit;
      }
      a:hover {
        text-decoration: underline;
      }
    -->
    </style>
  </head>
  <body>
    <pre>
<span class="comment-delimiter">;;;; </span><span class="comment">euler100.lisp --- Ryo's solution to the first 100 problems of Project Euler
</span>
<span class="comment-delimiter">;;; </span><span class="comment">License:
</span><span class="comment-delimiter">;; </span><span class="comment">this package is free software: you can redistribute it and/or modify
</span><span class="comment-delimiter">;; </span><span class="comment">it under the terms of the GNU General Public License as published
</span><span class="comment-delimiter">;; </span><span class="comment">by the Free Software Foundation, either version 3 of the License,
</span><span class="comment-delimiter">;; </span><span class="comment">or (at your option) any later version.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">this package is distributed in the hope that it will be useful, but
</span><span class="comment-delimiter">;; </span><span class="comment">WITHOUT ANY WARRANTY; without even the implied warranty of
</span><span class="comment-delimiter">;; </span><span class="comment">MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
</span><span class="comment-delimiter">;; </span><span class="comment">General Public License for more details.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">You should have received a copy of the GNU General Public License
</span><span class="comment-delimiter">;; </span><span class="comment">along with this package. If not, see <a href="https://www.gnu.org/licenses/">&lt;https://www.gnu.org/licenses/&gt;</a>.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span>
<span class="comment-delimiter">;;; </span><span class="comment">Commentary:
</span><span class="comment-delimiter">;;</span><span class="comment">
</span>
(<span class="keyword">defpackage</span> <span class="builtin">#:euler</span>
  (<span class="builtin">:use</span> <span class="builtin">:cl</span>))

(<span class="keyword">in-package</span> <span class="builtin">:euler</span>)

<hr />
<span class="comment-delimiter">;;;; </span><span class="comment">Utilies
</span><span class="comment-delimiter">;; </span><span class="comment">You could skip these functions and macros, they are just used here
</span><span class="comment-delimiter">;; </span><span class="comment">to make sure the code is neat and readable.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">However, if you are new to Common Lisp, this part can be a short
</span><span class="comment-delimiter">;; </span><span class="comment">introduction of Common Lisp.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span>
<span class="comment-delimiter">;;; </span><span class="comment">Constants:
</span><span class="comment-delimiter">;; </span><span class="comment">In Common Lisp, you could use:
</span><span class="comment-delimiter">;; </span><span class="comment">+ `(defparameter name value [docstring])'
</span><span class="comment-delimiter">;; </span><span class="comment">+ `(defvar name [value] [docstring])'
</span><span class="comment-delimiter">;; </span><span class="comment">to define global variables.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">The difference between `</span><span class="comment"><span class="constant">defparameter</span></span><span class="comment">' and `</span><span class="comment"><span class="constant">defvar</span></span><span class="comment">':
</span><span class="comment-delimiter">;; </span><span class="comment">if variable is already defined, it's value will not be
</span><span class="comment-delimiter">;; </span><span class="comment">rebind in `</span><span class="comment"><span class="constant">defvar</span></span><span class="comment">' but would be updated in `</span><span class="comment"><span class="constant">defparameter</span></span><span class="comment">'.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">Use `(defconstant name value [docstring])' can
</span><span class="comment-delimiter">;; </span><span class="comment">define global constant.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span>
(<span class="keyword">defconstant</span> <span class="variable-name">+thousand+</span> 1000    <span class="doc">"One thousand. "</span>)
(<span class="keyword">defconstant</span> <span class="variable-name">+million+</span>  1000000 <span class="doc">"One Million. "</span>)

<span class="comment-delimiter">;;; </span><span class="comment">Types:
</span><span class="comment-delimiter">;; </span><span class="comment">These types are more mathematically used
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">Types could be declared in functions like:
</span><span class="comment-delimiter">;; </span><span class="comment">+ (declare (type TYPE VAR...))
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;;   </span><span class="comment">normally, the type of variable could be determined by compiler.
</span><span class="comment-delimiter">;;   </span><span class="comment">or you could manually declare it, for example:
</span><span class="comment-delimiter">;;   </span><span class="comment">+ (or function symbol) either function or symbol
</span><span class="comment-delimiter">;;   </span><span class="comment">+ (member :key1 :key2) one of :key1, :key2
</span><span class="comment-delimiter">;;   </span><span class="comment">+ (satisfies testf)    ensures element pass testf
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">+ (the TYPE EXPR)
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;;   </span><span class="comment">normally, the return value of EXPR could be determined by compiler.
</span><span class="comment-delimiter">;;   </span><span class="comment">or you could manually declare it with `</span><span class="comment"><span class="constant">the</span></span><span class="comment">' form.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span>
(<span class="keyword">deftype</span> <span class="type">natural</span> (<span class="type">&amp;optional</span> (low 1) (high '*))
  <span class="doc">"Natural number starting from LOW, LOW + 1, ..., HIGH"</span>
  `(integer ,low ,high))

(<span class="keyword">deftype</span> <span class="type">positive-integer</span> ()
  <span class="doc">"Integers that is positive. "</span>
  '(integer 1))

<span class="comment-delimiter">;;; </span><span class="comment">Tools defining new functions and macros
</span><span class="comment-delimiter">;; </span><span class="comment">+ `</span><span class="comment"><span class="constant">with-gensym</span></span><span class="comment">' is a `</span><span class="comment"><span class="constant">let</span></span><span class="comment">' like functionality
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;;   </span><span class="comment">the utility function `</span><span class="comment"><span class="constant">gensym</span></span><span class="comment">' is used to avoid name conflicts
</span><span class="comment-delimiter">;;   </span><span class="comment">for example:
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;;       </span><span class="comment">`(let ((x 1)) (lambda (,arg) (+ ,arg x)))
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;;   </span><span class="comment">may introduce conflicts when arg is `</span><span class="comment"><span class="constant">x</span></span><span class="comment">'
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">+ `</span><span class="comment"><span class="constant">defun-inline</span></span><span class="comment">'
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;;   </span><span class="comment">we could declaim a function as `</span><span class="comment"><span class="constant">inline</span></span><span class="comment">' to make it
</span><span class="comment-delimiter">;;   </span><span class="comment">expanded directly when calling rather than doing funcall
</span><span class="comment-delimiter">;;   </span><span class="comment">to cut off some function calling time.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">+ `</span><span class="comment"><span class="constant">defun-cached</span></span><span class="comment">'
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;;   </span><span class="comment">we could use a hash-table to cached the function results
</span><span class="comment-delimiter">;;   </span><span class="comment">by function arguments: if arg is found in cache, return
</span><span class="comment-delimiter">;;   </span><span class="comment">the cached value, otherwise, compute the value.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span>
(<span class="keyword">defmacro</span> <span class="function-name">with-gensym</span> (vars <span class="type">&amp;body</span> body)
  <span class="doc">"Bind VARS list with gensym and evaluate BODY.

Syntax:

    (with-gensym ( var* ) . BODY)

"</span>
  (<span class="warning">assert</span> (every #'symbolp vars))
  `(<span class="keyword">let</span> ,(mapcar (<span class="keyword">lambda</span> (var) `(,var ',(gensym (symbol-name var)))) vars)
     ,@body))

(<span class="keyword">defmacro</span> <span class="function-name">defun-inline</span> (name lambda-list <span class="type">&amp;body</span> body)
  <span class="doc">"Define an inlined function NAME. "</span>
  `(<span class="keyword">progn</span>
     (<span class="keyword">declaim</span> (inline ,name))
     (<span class="keyword">defun</span> ,name ,lambda-list ,@body)))

(<span class="keyword">defmacro</span> <span class="function-name">defun-cached</span> (name lambda-list <span class="type">&amp;body</span> body)
  <span class="doc">"Define a cached function called NAME.

Syntax:

    (defun-cached
      { NAME | ( NAME &amp;key test (key (first LAMBDA-LIST)) fallback) }
         LAMBDA-LIST
      docstring?
      declaration*
      . body)

"</span>
  (<span class="keyword">destructuring-bind</span> (name <span class="type">&amp;key</span> (test 'eql) (key (first lambda-list)) fallback)
      (<span class="keyword">if</span> (listp name) name (list name))
    (<span class="keyword">declare</span> (type (member eql equal) test)
             (type symbol name))
    (<span class="keyword">with-gensym</span> (cache keyv val fallbackv)
      `(<span class="keyword">let</span> ((,cache (make-hash-table <span class="builtin">:test</span> ',test))
             (,fallbackv ,fallback))
         (<span class="keyword">defun</span> ,name ,lambda-list
           ,@(<span class="keyword">let</span> ((docstring (pop body)))
               (<span class="keyword">cond</span> ((stringp docstring) (list docstring))
                     (t (push docstring body) nil)))
           ,@(<span class="keyword">loop</span> for expr = (pop body)
                   while (and (listp expr) (eq (car expr) 'declare))
                   collect expr
                   finally (push expr body))
           (<span class="keyword">let*</span> ((,keyv ,key)
                  (,val  (gethash ,keyv ,cache ,fallbackv)))
             (<span class="keyword">if</span> (equal ,val ,fallbackv)
                 (setf (gethash ,keyv ,cache) (<span class="keyword">progn</span> ,@body))
                 ,val)))))))

<span class="comment-delimiter">;;; </span><span class="comment">Iteration:
</span><span class="comment-delimiter">;; </span><span class="comment">In Common Lisp, we have a very handy `</span><span class="comment"><span class="constant">loop</span></span><span class="comment">' utility function:
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;;    </span><span class="comment">(loop for i in list               ;; e1, e2, e3, ... if list is (e1 e2 e3 ...)
</span><span class="comment-delimiter">;;          </span><span class="comment">for j from 1 below 20 by 2  ;; 1, 3, 5, 7, ...
</span><span class="comment-delimiter">;;          </span><span class="comment">for k from 20 downto 0 by 4 ;; 20, 16, 12, 8, ...
</span><span class="comment-delimiter">;;          </span><span class="comment">if test
</span><span class="comment-delimiter">;;            </span><span class="comment">do expr
</span><span class="comment-delimiter">;;          </span><span class="comment">do expr
</span><span class="comment-delimiter">;;          </span><span class="comment">while test)
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">These iteration macros are used as shortcuts of loop.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">*-dolist -&gt; (*-dolist (elem list) &amp;body)
</span><span class="comment-delimiter">;; </span><span class="comment">*-repeat -&gt; (*-repeat (i n) &amp;body)
</span><span class="comment-delimiter">;;             </span><span class="comment">(*-repeat (i n m step) &amp;body)
</span><span class="comment-delimiter">;;</span><span class="comment">
</span>
(<span class="keyword">defmacro</span> <span class="function-name">or-dolist</span> ((elem list) <span class="type">&amp;body</span> body)
  <span class="doc">"Iter ELEM in LIST and return if BODY is true. "</span>
  `(<span class="keyword">the</span> boolean (<span class="keyword">loop</span> for ,elem in ,list if (<span class="keyword">progn</span> ,@body) return t)))

(<span class="keyword">defmacro</span> <span class="function-name">and-dolist</span> ((elem list) <span class="type">&amp;body</span> body)
  <span class="doc">"Iter ELEM in LIST and return if BODY are all true. "</span>
  `(<span class="keyword">the</span> boolean (not (<span class="keyword">loop</span> for ,elem in ,list if (not (<span class="keyword">progn</span> ,@body)) return t))))

(<span class="keyword">defmacro</span> <span class="function-name">and-repeat</span> ((i n <span class="type">&amp;optional</span> m (step 1)) <span class="type">&amp;body</span> body)
  <span class="doc">"Loop I from repeat N times, and logic and the BODY result.
Return t if all pass, nil if any fails.

Example:

    (repeat-and (i 20)     (evenp i)) ; =&gt; i = 0, 1, 2, ..., 19
    (repeat-and (i 2 20 2) (evenp i)) ; =&gt; i = 2, 4, 6, ..., 20
"</span>
  `(<span class="keyword">the</span> boolean
     ,(<span class="keyword">if</span> m
          `(<span class="keyword">loop</span> for ,i from ,n upto ,m by ,step
                 if (not (<span class="keyword">progn</span> ,@body))
                   return nil
                 finally (<span class="keyword">return</span> t))
          `(<span class="keyword">loop</span> for ,i below ,n
                 if (not (<span class="keyword">progn</span> ,@body))
                   return nil
                 finally (<span class="keyword">return</span> t)))))

(<span class="keyword">defmacro</span> <span class="function-name">windowed-dolist</span> ((window size list <span class="type">&amp;rest</span> result) <span class="type">&amp;body</span> body)
  <span class="doc">"Iter on LIST with each WINDOW as subsequence of LIST with SIZE. "</span>
  (<span class="keyword">with-gensym</span> (len lst shift window-size)
    `(<span class="keyword">loop</span> with ,lst = ,list
           with ,window-size = ,size
           for ,len from (length ,lst) downto ,window-size
           for ,shift on ,lst
           for ,window = (subseq shift 0 ,window-size)
           do (<span class="keyword">progn</span> ,@body)
           finally (<span class="keyword">return</span> ,result))))

(<span class="keyword">defun</span> <span class="function-name">windowed-mapcar</span> (func window-size list <span class="type">&amp;optional</span> (step 1))
  <span class="doc">"Like `</span><span class="doc"><span class="constant">mapcar</span></span><span class="doc">' with WINDOW-SIZE for given FUNC on LIST. "</span>
  (<span class="keyword">loop</span> for len from (length list) downto window-size
        for shift on list by (curry #'nthcdr step)
        collect (apply func (subseq shift 0 window-size))))

(<span class="keyword">defun</span> <span class="function-name">range-list</span> (start end <span class="type">&amp;optional</span> (step 1))
  <span class="doc">"Return a list of number of range (START END) by STEP. "</span>
  (<span class="keyword">cond</span> ((&lt; step 0) (<span class="keyword">loop</span> for i from start downto end by (abs step) collect i))
        ((&gt; step 0) (<span class="keyword">loop</span> for i from start upto   end by step       collect i))
        (t          (<span class="warning">error</span> <span class="string">"Step is zero. "</span>))))

<span class="comment-delimiter">;;; </span><span class="comment">Shortcuts:
</span><span class="comment-delimiter">;; </span><span class="comment">nothing, just my coding flavour.
</span>
(defun-inline 2- (x)
  <span class="string">"Return X - 2. "</span>
  (<span class="keyword">declare</span> (type number x))
  (- x 2))

(defun-inline 2+ (x)
  <span class="string">"Return x + 2. "</span>
  (+ 2 x))

(defun-inline 2* (x)
  <span class="string">"Return x * 2. "</span>
  (* 2 x))

(defun-inline atomize (obj)
  <span class="string">"Return OBJ as atom. "</span>
  (<span class="keyword">if</span> (listp obj) (car obj) obj))

(defun-inline listfy (obj)
  <span class="string">"Return OBJ as list. "</span>
  (<span class="keyword">if</span> (atom obj) (list obj) obj))

<span class="comment-delimiter">;;; </span><span class="comment">Functional Programming
</span><span class="comment-delimiter">;; </span><span class="comment">In my opinion, when we call function programming, we
</span><span class="comment-delimiter">;; </span><span class="comment">are referring computing not only values, but also the function
</span><span class="comment-delimiter">;; </span><span class="comment">that return values.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span>
<span class="comment-delimiter">;; </span><span class="comment">Function Compose
</span><span class="comment-delimiter">;; </span><span class="comment">We can see a process as a chained function calling.
</span><span class="comment-delimiter">;; </span><span class="comment">For example, a procedure:
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;;   </span><span class="comment">(progn
</span><span class="comment-delimiter">;;     </span><span class="comment">(do-this)
</span><span class="comment-delimiter">;;     </span><span class="comment">(then-do-this))
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">Can be written as:
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;;   </span><span class="comment">(then-do-this (do-this))
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">Assuming each `</span><span class="comment"><span class="constant">then-do-this</span></span><span class="comment">' and `</span><span class="comment"><span class="constant">do-this</span></span><span class="comment">' return an updated status.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span>
(<span class="keyword">defun</span> <span class="function-name">compose</span> (f g)
  <span class="doc">"Return a function h(x) = f(g(x)). "</span>
  (<span class="keyword">lambda</span> (<span class="type">&amp;rest</span> args) (funcall f (apply g args))))

<span class="comment-delimiter">;; </span><span class="comment">For performance concern, we could rewrite the expression
</span><span class="comment-delimiter">;; </span><span class="comment">at compile time for better performance.
</span>
(<span class="keyword">define-compiler-macro</span> <span class="function-name">compose</span> (<span class="type">&amp;whole</span> form f g)
  <span class="doc">"Rewriting Rules:
+ (compose f (compose g h)) -&gt; (lambda (args) (f (g (h args))))
+ (compose (compose f g) h) -&gt; (lambda (args) (f (g (h args))))
"</span>
  (<span class="keyword">declare</span> (ignore f g))
  (<span class="keyword">with-gensym</span> (args)
    (<span class="keyword">labels</span> ((extract (expr)
               (<span class="keyword">if</span> (and (listp expr) (eq (first expr) 'compose))
                   (append (extract (second expr)) (extract (third expr)))
                   (list expr)))
             (expand (funcs)
               (<span class="keyword">if</span> (endp (cdr funcs))
                   `(apply ,(car funcs) ,args)
                   `(funcall ,(car funcs) ,(expand (cdr funcs))))))
      `(<span class="keyword">lambda</span> (<span class="type">&amp;rest</span> ,args) ,(expand (extract form))))))

<span class="comment-delimiter">;; </span><span class="comment">This is a trivial implementation of arity.
</span><span class="comment-delimiter">;; </span><span class="comment">In Common Lisp, a simple function lambda list is like:
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;;     </span><span class="comment">(lambda (x y z))
</span><span class="comment-delimiter">;;     </span><span class="comment">(lambda (x &amp;optional y))
</span><span class="comment-delimiter">;;     </span><span class="comment">(lambda (y &amp;key k1 k2))
</span><span class="comment-delimiter">;;     </span><span class="comment">(lambda (&amp;rest args))
</span><span class="comment-delimiter">;;     </span><span class="comment">(lambda (y &amp;key key1 &amp;allow-other-keys))
</span><span class="comment-delimiter">;;</span><span class="comment">
</span>
(<span class="keyword">defun</span> <span class="function-name">args</span> (<span class="type">&amp;rest</span> args)
  <span class="doc">"Return input arguments as list. "</span>
  args)

(<span class="keyword">defun</span> <span class="function-name">nth-arg</span> (n)
  <span class="doc">"Return a function that pick Nth argument of input arguments. "</span>
  (<span class="keyword">lambda</span> (<span class="type">&amp;rest</span> args) (nth n args)))

(<span class="keyword">defun</span> <span class="function-name">nth-arg*</span> (<span class="type">&amp;rest</span> ns)
  <span class="doc">"Return NS elements of input arguments as list. "</span>
  (<span class="keyword">lambda</span> (<span class="type">&amp;rest</span> args) (mapcar (rcurry #'nth args) ns)))

<span class="comment-delimiter">;; </span><span class="comment">The curry is a interesting mechanics especially when you
</span><span class="comment-delimiter">;; </span><span class="comment">want to write some fancy code like:
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;;    </span><span class="comment">(mapcar (curry  #'nth 2) list)        ; =&gt; (mapcar #'second list)
</span><span class="comment-delimiter">;;    </span><span class="comment">(mapcar (rcurry #'nth list) '(1 2 3)) ; =&gt; ((nth 1 list) (nth 2 list) (nth 3 list))
</span><span class="comment-delimiter">;;</span><span class="comment">
</span>
(<span class="keyword">defun</span> <span class="function-name">curry</span> (func arg)
  <span class="doc">"Left curry FUNC with ARG. "</span>
  (<span class="keyword">lambda</span> (<span class="type">&amp;rest</span> args) (apply func (cons arg args))))

(<span class="keyword">defun</span> <span class="function-name">curry*</span> (func <span class="type">&amp;rest</span> arg)
  <span class="doc">"Left curry FUNC with ARGS. "</span>
  (<span class="keyword">lambda</span> (<span class="type">&amp;rest</span> args) (apply func (append arg args))))

(<span class="keyword">defun</span> <span class="function-name">rcurry</span> (func arg)
  <span class="doc">"Return a function of g(args) = f(args, arg). "</span>
  (<span class="keyword">lambda</span> (<span class="type">&amp;rest</span> args) (apply func (append args (list arg)))))

(<span class="keyword">defun</span> <span class="function-name">rcurry*</span> (func <span class="type">&amp;rest</span> arg*)
  <span class="doc">"Return a function of g(args) = f(args, arg). "</span>
  (<span class="keyword">lambda</span> (<span class="type">&amp;rest</span> args) (apply func (append args arg*))))

<span class="comment-delimiter">;;; </span><span class="comment">Data Structure
</span><span class="comment-delimiter">;; </span><span class="comment">An alist is a list of elements (key . value). You can use `</span><span class="comment"><span class="constant">assoc</span></span><span class="comment">' to
</span><span class="comment-delimiter">;; </span><span class="comment">get element by the key:
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;;    </span><span class="comment">(assoc 'a '((a . 1) (b . 2))) ; =&gt; (a . 1)
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">However, when the alist size got larger, it's not so performance
</span><span class="comment-delimiter">;; </span><span class="comment">fetching elements from list data structure, so switching to hash-table
</span><span class="comment-delimiter">;; </span><span class="comment">would be more efficiency.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">Note that there's other key-value pair data structure called plist
</span><span class="comment-delimiter">;; </span><span class="comment">constructed by list:
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;;    </span><span class="comment">(getf '(:a 1 :b 2) :b) ; =&gt; 2
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">And if you are storing a data structure with fixed size of elements,
</span><span class="comment-delimiter">;; </span><span class="comment">maybe using array would bring better performance.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span>
(<span class="keyword">defun</span> <span class="function-name">alist&lt;-hash-table</span> (hash-table)
  <span class="doc">"Turn HASH-TABLE to ALIST.
Return an alist of HASH-TABLE's key and value. "</span>
  (<span class="keyword">declare</span> (type hash-table hash-table))
  (<span class="keyword">let</span> ((alist ()))
    (maphash (<span class="keyword">lambda</span> (k v) (push (cons k v) alist)) hash-table)
    alist))

(<span class="keyword">defun</span> <span class="function-name">hash-table&lt;-alist</span> (alist <span class="type">&amp;key</span> hash-table (test 'eql) (if-exist <span class="builtin">:replace</span>) fallback)
  <span class="doc">"Turn ALIST into HASH-TABLE.
Return a HASH-TABLE.

Parameters:
+ ALIST: an alist like ((key . val))
+ HASH-TABLE: if not given, create a new hash-table of type TEST
+ TEST: either `</span><span class="doc"><span class="constant">eql</span></span><span class="doc">' or `</span><span class="doc"><span class="constant">equal</span></span><span class="doc">'
+ IF-EXIST: if already exists in hash table, resolve conflicts
  if is a function, it should be a function like (lambda (prev curr) new)
+ FALLBACK: default fallback value of `</span><span class="doc"><span class="constant">gethash</span></span><span class="doc">'.
"</span>
  (<span class="keyword">declare</span> (type list alist)
           (type (member eql equal) test)
           (type (or function (member <span class="builtin">:replace</span> <span class="builtin">:keep</span>)) if-exist))
  (<span class="keyword">let</span> ((hash-table (<span class="keyword">if</span> (hash-table-p hash-table) hash-table
                        (make-hash-table <span class="builtin">:test</span> test)))
        (if-exist   (<span class="keyword">if</span> (functionp if-exist) if-exist
                        (<span class="keyword">ecase</span> if-exist
                          (<span class="builtin">:replace</span> (nth-arg 1))
                          (<span class="builtin">:keep</span>    (nth-arg 0))))))
    (<span class="keyword">loop</span> for (key . val) in alist
          for prev = (gethash key hash-table fallback)
          do (setf (gethash key hash-table)
                   (<span class="keyword">if</span> (equal fallback prev) val
                       (funcall if-exist prev val)))
          finally (<span class="keyword">return</span> hash-table))))

(<span class="keyword">defun</span> <span class="function-name">alist-reduce</span> (function alists <span class="type">&amp;key</span> (test 'eql) fallback)
  <span class="doc">"Reduce on alist key with function.
Return a new alist.

Parameters:
+ FUNCTION: the function used to reduce (lambda (prev curr) new)
+ ALISTS: a list of alists
+ TEST: how the key is hashed (eql or equal)
+ FALLBACK: see `</span><span class="doc"><span class="constant">hash-table&lt;-alist</span></span><span class="doc">'
"</span>
  (<span class="keyword">declare</span> (type function function)
           (type list alists)
           (type (member eql equal) test))
  (alist&lt;-hash-table
   (reduce (<span class="keyword">lambda</span> (hash alist)
             (hash-table&lt;-alist alist <span class="builtin">:test</span>       test
                                      <span class="builtin">:if-exist</span>   function
                                      <span class="builtin">:fallback</span>   fallback
                                      <span class="builtin">:hash-table</span> hash))
           alists
           <span class="builtin">:initial-value</span> (make-hash-table <span class="builtin">:test</span> test))))

(<span class="keyword">defun</span> <span class="function-name">group</span> (sequence <span class="type">&amp;key</span> (key #'identity) (reduce #'cons) (test 'equal) initial-value)
  <span class="doc">"Group elements in SEQUENCE.

Parameters:
+ SEQUENCE: a `</span><span class="doc"><span class="constant">list</span></span><span class="doc">', `</span><span class="doc"><span class="constant">array</span></span><span class="doc">' or so sequence
+ KEY: apply KEY on element as hash key
  should be a function with lambda-list:

    (lambda (elem) return-value-as-elem-compare-key)

+ TEST: the grouping hash
  should be `</span><span class="doc"><span class="constant">eql</span></span><span class="doc">' or `</span><span class="doc"><span class="constant">equal</span></span><span class="doc">' (like `</span><span class="doc"><span class="constant">make-hash-table</span></span><span class="doc">')

+ REDUCE: how the grouped value is reduced with new element,
  should be a function with lambda-list:

    (lambda (new old) return-value-as-old)

+ INITIAL-VALUE: the init OLD value (default as `</span><span class="doc"><span class="constant">nil</span></span><span class="doc">')

Example:

    (group '(1 2 1 2 3)) ; =&gt; ((3 . (3)) (2 . (2 2)) (1 . (1 1)))

"</span>
  (<span class="keyword">declare</span> (type sequence sequence)
           (type (function (t) *)    key)
           (type (member eql equal)     test)
           (type (function (t t) *) reduce))
  (<span class="keyword">let</span> ((group (make-hash-table <span class="builtin">:test</span> test)))
    (map 'nil (<span class="keyword">lambda</span> (elem)
                (<span class="keyword">let</span> ((key (funcall key elem)))
                  (setf (gethash key group)
                        (funcall reduce elem (gethash key group initial-value)))))
         sequence)
    (alist&lt;-hash-table group)))

<hr />
<span class="comment-delimiter">;;; </span><span class="comment">Problem 1. Multiples of 3 or 5
</span><span class="comment-delimiter">;; </span><span class="comment">If we list all the natural numbers below 10 that are multiples of 3
</span><span class="comment-delimiter">;; </span><span class="comment">or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">Find the sum of all the multiples of 3 or 5 below 1000.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span>
<span class="comment-delimiter">;; </span><span class="comment">Definition:
</span><span class="comment-delimiter">;; </span><span class="comment">If NUMBER can be moded by divisor, NUMBER mod DIVISOR is 0.
</span>
(defun-inline modp (number divisor)
  <span class="string">"Test if NUMBER can be moded by DIVISOR. "</span>
  (<span class="keyword">declare</span> (type integer number divisor))
  (zerop (mod number divisor)))

(<span class="keyword">defun</span> <span class="function-name">problem1</span> (<span class="type">&amp;optional</span> (dividers '(3 5)) (max 1000))
  <span class="doc">"Find the sum of all the multiples of 3 or 5 below 1000. "</span>
  (<span class="keyword">loop</span> for n from 3 below max
        if (or-dolist (d dividers) (modp n d)) sum n))

<hr />
<span class="comment-delimiter">;;; </span><span class="comment">Problem 2. Even Fibonacci Numbers
</span><span class="comment-delimiter">;; </span><span class="comment">Each new term in the Fibonacci sequence is generated by adding
</span><span class="comment-delimiter">;; </span><span class="comment">the previous two terms. By starting with 1 and 2, the first
</span><span class="comment-delimiter">;; </span><span class="comment">10 terms will be:
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;;    </span><span class="comment">1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">By considering the terms in the Fibonacci sequence whose values
</span><span class="comment-delimiter">;; </span><span class="comment">do not exceed four million, find the sum of the even-valued
</span><span class="comment-delimiter">;; </span><span class="comment">terms.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span>
<span class="comment-delimiter">;; </span><span class="comment">Definition:
</span><span class="comment-delimiter">;; </span><span class="comment">Fib(1) = 1
</span><span class="comment-delimiter">;; </span><span class="comment">Fib(2) = 2
</span><span class="comment-delimiter">;; </span><span class="comment">Fib(n) = Fib(n - 1) + Fib(n - 2)
</span>
(defun-cached fibonacci (n)
  <span class="string">"Return Nth Fibonacci number. "</span>
  (<span class="keyword">declare</span> (type positive-integer n))
  (<span class="keyword">if</span> (&lt;= n 2)
      n
      (+ (fibonacci (1- n))
         (fibonacci (2- n)))))

<span class="comment-delimiter">;; </span><span class="comment">Note: it would be much more slower if using fibonacci
</span><span class="comment-delimiter">;; </span><span class="comment">without cached implementation.
</span>
(<span class="keyword">defun</span> <span class="function-name">problem2</span> (<span class="type">&amp;optional</span> (max 4000000))
  <span class="doc">"Find the sum of the even Fibonacci number below MAX. "</span>
  (<span class="keyword">loop</span> for n from 1
        for fib = (fibonacci n)
        while (&lt; fib max)
        if (evenp fib)
          sum fib))

<span class="comment-delimiter">;; </span><span class="comment">Reuse the fibonacci number when increasing, this is
</span><span class="comment-delimiter">;; </span><span class="comment">faster as hashing time is skipped.
</span>
(<span class="keyword">defun</span> <span class="function-name">problem2-faster</span> (<span class="type">&amp;optional</span> (max 4000000))
  <span class="doc">"Find the sum of the even Fibonacci number below MAX. "</span>
  (<span class="keyword">loop</span> with f1 = 1
        with f2 = 2
        while (&lt; f2 max)
        if (evenp f2)
          sum f2
        do (shiftf f1 f2 (+ f1 f2))))

<hr />
<span class="comment-delimiter">;;; </span><span class="comment">Problem 3. Largest Prime Factor
</span><span class="comment-delimiter">;; </span><span class="comment">The prime factors of 13195 are 5, 7, 13 and 29.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">What is the largest prime factor of the number 600851475143?
</span><span class="comment-delimiter">;;</span><span class="comment">
</span>
<span class="comment-delimiter">;; </span><span class="comment">Definition:
</span><span class="comment-delimiter">;; </span><span class="comment">nth-prime(1) = 2
</span><span class="comment-delimiter">;; </span><span class="comment">nth-prime(2) = 3
</span><span class="comment-delimiter">;; </span><span class="comment">nth-prime(n) = next prime starting from nth-prime(n - 1)
</span>
(defun-cached nth-prime (nth)
  <span class="string">"Return Nth prime. "</span>
  (<span class="keyword">declare</span> (type positive-integer nth))
  (<span class="keyword">cond</span> ((= nth 1) 2)
        ((= nth 2) 3)
        (t (<span class="keyword">loop</span> for p from (2+ (nth-prime (1- nth))) by 2
                 if (primep p) return p))))

<span class="comment-delimiter">;; </span><span class="comment">Definition:
</span><span class="comment-delimiter">;; </span><span class="comment">If a number can be divided into prod(pi^ni), it is not a prime,
</span><span class="comment-delimiter">;; </span><span class="comment">otherwise, is a prime.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">So n is not a prime if all primes less then sqrt(n)
</span><span class="comment-delimiter">;; </span><span class="comment">cannot mod n (not (modp n p)).
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">And 1 is not prime.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span>
(defun-cached (primep <span class="builtin">:fallback</span> <span class="builtin">:null</span>) (n)
  <span class="string">"Test if N is prime number. "</span>
  (<span class="keyword">declare</span> (type natural n))
  (and (/= n 1)
       (<span class="keyword">loop</span> with max = (truncate (sqrt n))
             for i from 1
             for p = (nth-prime i)
             while (&lt;= p max)
             if (modp n p)
               return nil
             finally (<span class="keyword">return</span> t))))

(<span class="keyword">defun</span> <span class="function-name">problem3</span> (<span class="type">&amp;optional</span> (n 600851475143))
  <span class="doc">"Find the largest prime factor of the number N. "</span>
  (<span class="keyword">declare</span> (type unsigned-byte n))
  (<span class="keyword">loop</span> for div from (truncate (sqrt n)) downto 2
        if (and (modp n div) (primep div))
          return div))

<span class="comment-delimiter">;; </span><span class="comment">Note: here's another approach:
</span>
<span class="comment-delimiter">;; </span><span class="comment">Definition:
</span><span class="comment-delimiter">;; </span><span class="comment">prime-factor-list(n) = (n) if n is prime
</span><span class="comment-delimiter">;; </span><span class="comment">prime-factor-list(n) = append of
</span><span class="comment-delimiter">;;   </span><span class="comment">prime-factor-list(a), prime-factor-list(b) if n = a * b
</span>
(defun-cached prime-factor-list (n)
  <span class="string">"Return a list of prime factors for number N. "</span>
  (<span class="keyword">declare</span> (type natural n))
  (<span class="keyword">loop</span> for div from (truncate (sqrt n)) downto 2
        if (modp n div)
          return (append (prime-factor-list div)
                         (prime-factor-list (/ n div)))
        finally (<span class="keyword">return</span> (<span class="keyword">when</span> (/= n 1) (list n)))))

<span class="comment-delimiter">;; </span><span class="comment">Much slower when N is very large.
</span>
<span class="comment-delimiter">;; </span><span class="comment">(defun factors-slower (n)
</span><span class="comment-delimiter">;;   </span><span class="comment">"Return a list of (factor . order) for number N. "
</span><span class="comment-delimiter">;;   </span><span class="comment">(loop for i from 1
</span><span class="comment-delimiter">;;         </span><span class="comment">for p from (nth-prime i)
</span><span class="comment-delimiter">;;         </span><span class="comment">if (modp n p)
</span><span class="comment-delimiter">;;           </span><span class="comment">collect (loop with order = 0
</span><span class="comment-delimiter">;;                         </span><span class="comment">do (setf n (/ n p))
</span><span class="comment-delimiter">;;                         </span><span class="comment">do (incf order)
</span><span class="comment-delimiter">;;                         </span><span class="comment">while (modp n p)
</span><span class="comment-delimiter">;;                         </span><span class="comment">finally (return (cons p order)))
</span><span class="comment-delimiter">;;         </span><span class="comment">while (/= n 1)))
</span>
(<span class="keyword">defun</span> <span class="function-name">factors</span> (n)
  <span class="doc">"Return a list of (factor . order) for number N. "</span>
  (<span class="keyword">declare</span> (type natural n))
  (group (prime-factor-list n)
         <span class="builtin">:reduce</span> (<span class="keyword">lambda</span> (- order) (1+ order))
         <span class="builtin">:initial-value</span> 0))

(<span class="keyword">defun</span> <span class="function-name">problem3-other-way</span> (<span class="type">&amp;optional</span> (n 600851475143))
  <span class="doc">"Find the largest prime factor of the number N. "</span>
  (car (first (sort (factors n) #'&gt; <span class="builtin">:key</span> #'car))))

<hr />
<span class="comment-delimiter">;;; </span><span class="comment">Problem 4. Largest Palindrome Product
</span><span class="comment-delimiter">;; </span><span class="comment">A palindromic number reads the same both ways. The largest palindrome
</span><span class="comment-delimiter">;; </span><span class="comment">made from the product of two 2-digit numbers is 9009 = 91 * 99.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">Find the largest palindrome made from the product of two 3-digit numbers.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span>
<span class="comment-delimiter">;; </span><span class="comment">Here introduced the p-based number expression.
</span>
<span class="comment-delimiter">;; </span><span class="comment">Notation:
</span><span class="comment-delimiter">;; </span><span class="comment">n = sum({ p^ei * ai })
</span>
(defun-inline p-shift (n <span class="type">&amp;optional</span> (base 10))
  <span class="string">"Shift number N under BASE. "</span>
  (<span class="keyword">declare</span> (type unsigned-byte n base))
  (floor n base))

(defun-inline p-left-shift (n <span class="type">&amp;optional</span> (base 10))
  <span class="string">"Left shift number N under BASE. "</span>
  (<span class="keyword">declare</span> (type unsigned-byte n base))
  (* n base))

<span class="comment-delimiter">;; </span><span class="comment">So for p-shift (right):
</span><span class="comment-delimiter">;; </span><span class="comment">p-shift(sum({ p^ei * ai })) = sum({ p^(ei - 1) * ai })
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">If n = 0, p-digit(n) = '(0)
</span><span class="comment-delimiter">;; </span><span class="comment">If n /= 0, p-digit(n) = p-digit(p-shift(n)), n mod base
</span><span class="comment-delimiter">;;</span><span class="comment">
</span>
(<span class="keyword">defun</span> <span class="function-name">p-digits</span> (n <span class="type">&amp;optional</span> (base 10))
  <span class="doc">"Return a list of digits for number N under BASE. "</span>
  (<span class="keyword">declare</span> (type unsigned-byte n))
  (<span class="keyword">if</span> (zerop n) '(0)
      (<span class="keyword">loop</span> with p-digit = ()
            for v = n then (p-shift v base) until (zerop v)
            do (push (mod v base) p-digit)
            finally (<span class="keyword">return</span> p-digit))))

<span class="comment-delimiter">;; </span><span class="comment">Definition:
</span><span class="comment-delimiter">;; </span><span class="comment">If a sequence is palindromic,
</span><span class="comment-delimiter">;; </span><span class="comment">sequence(i) = sequence(length(sequence) - i)
</span><span class="comment-delimiter">;;</span><span class="comment">
</span>
(<span class="keyword">defun</span> <span class="function-name">palindromic-sequence-p</span> (sequence <span class="type">&amp;optional</span> (test #'=))
  <span class="doc">"Test if SEQUENCE is palindromic.
Return t or nil.

Parameters:
+ SEQUENCE: a sequence to"</span>
  (<span class="keyword">declare</span> (type sequence sequence)
           (type function test))
  <span class="comment-delimiter">;; </span><span class="comment">convert sequence as simple vector to accelerate
</span>  (<span class="keyword">let*</span> ((arr   (coerce sequence 'simple-vector))
         (len   (length arr))
         (len-1 (1- len)))
    (and-repeat (i (floor len 2))
      (funcall test (svref arr i) (svref arr (- len-1 i))))))

(<span class="keyword">defun</span> <span class="function-name">palindromep</span> (n <span class="type">&amp;optional</span> (base 10))
  <span class="doc">"Test if N is palindrome number under BASE. "</span>
  (palindromic-sequence-p (p-digits n base)))

<span class="comment-delimiter">;; </span><span class="comment">A palindrome number can be considered as:
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;;    </span><span class="comment">100000 * a + 10000 * b + 1000 * c + 100 * c + 10 * b + a
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">=&gt; 100001 * a + 10010 * b + 1100 * c
</span><span class="comment-delimiter">;; </span><span class="comment">=&gt; 11 * (9091 * a + 910 * b + 100 * c)
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">so the `</span><span class="comment"><span class="constant">j</span></span><span class="comment">' loop would search on number that moded by 11.
</span><span class="comment-delimiter">;; </span><span class="comment">cannot reduce much computing cost.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span>
(<span class="keyword">defun</span> <span class="function-name">problem4</span> ()
  <span class="doc">"Return the largest palindrome made from the product of two 3-digit numbers. "</span>
  (<span class="keyword">let</span> ((products ()))
    (<span class="keyword">loop</span> for i from 999 downto 100 do
      (<span class="keyword">loop</span> for j from (* 11 (floor i 11)) downto 110 by 11
            for n = (* i j)
            if (palindromep n)
              do (push n products)))
    (first (sort products #'&gt;))))

<hr />

<span class="comment-delimiter">;;; </span><span class="comment">Problem 5. Smallest Multiple
</span><span class="comment-delimiter">;; </span><span class="comment">2520 is the smallest number that can be divided by each of the numbers
</span><span class="comment-delimiter">;; </span><span class="comment">from 1 to 10 without any remainder.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">What is the smallest positive number that is evenly divisible by all
</span><span class="comment-delimiter">;; </span><span class="comment">the numbers from 1 to 20?
</span><span class="comment-delimiter">;;</span><span class="comment">
</span>
<span class="comment-delimiter">;; </span><span class="comment">This is like the inverse function of `</span><span class="comment"><span class="constant">factors</span></span><span class="comment">'.
</span>
(<span class="keyword">defun</span> <span class="function-name">int&lt;-factors</span> (factors)
  <span class="doc">"Turn list ((factor . order)) into integer. "</span>
  (<span class="keyword">the</span> integer
    (reduce (<span class="keyword">lambda</span> (mul factor-order)
              (<span class="keyword">destructuring-bind</span> (factor . order) factor-order
                (* mul (expt factor order))))
            factors
            <span class="builtin">:initial-value</span> 1)))

<span class="comment-delimiter">;; </span><span class="comment">If N is divided by M, the factors of N and M would have same factor
</span><span class="comment-delimiter">;; </span><span class="comment">and every factor order of M should less or equal to factor order of
</span><span class="comment-delimiter">;; </span><span class="comment">N.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span>
(<span class="keyword">defun</span> <span class="function-name">problem5</span> (<span class="type">&amp;optional</span> (max 20))
  <span class="doc">"Return the smallest positive number that is evenly divisible by
the numbers from 1 to MAX. "</span>
  (int&lt;-factors (alist-reduce #'max (mapcar #'factors (range-list 2 max)))))

<hr />

<span class="comment-delimiter">;;; </span><span class="comment">Problem 6. Sum Square Difference
</span><span class="comment-delimiter">;; </span><span class="comment">The sum of the squares of the first ten natural numbers is,
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;;    </span><span class="comment">1^2 + 2^2 + ... + 10^2 = 385
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">The square of the sum of the first ten natural numbers is,
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;;    </span><span class="comment">(1 + 2 + ... + 10)^2 = 55^2 = 3025
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">Hence the difference between the sum of the squares of the
</span><span class="comment-delimiter">;; </span><span class="comment">first ten natural numbers and the square of the sum is
</span><span class="comment-delimiter">;; </span><span class="comment">3025 - 385 = 2640.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">Find the difference between the sum of the squares of the
</span><span class="comment-delimiter">;; </span><span class="comment">first one hundred natural numbers and the square of the
</span><span class="comment-delimiter">;; </span><span class="comment">sum.
</span>
(defun-inline square (x)
  <span class="string">"Return square of X. "</span>
  (<span class="keyword">declare</span> (type number x))
  (* x x))

(<span class="keyword">defun</span> <span class="function-name">sum-of-squares</span> (sequence)
  <span class="doc">"Return sum of squares of NUMS. "</span>
  (reduce #'+ (map 'list #'square sequence)))

(<span class="keyword">defun</span> <span class="function-name">sum</span> (sequence)
  <span class="doc">"Return sum of SEQUENCE. "</span>
  (<span class="keyword">let</span> ((sum 0))
    (map nil (<span class="keyword">lambda</span> (x) (incf sum x)) sequence)
    sum))

(<span class="keyword">defun</span> <span class="function-name">problem6</span> (<span class="type">&amp;optional</span> (max 100))
  <span class="doc">"Return the difference sum of the squares and square of the sum. "</span>
  (<span class="keyword">let</span> ((nums (range-list 1 max)))
    (abs (- (sum-of-squares nums) (square (sum nums))))))

<hr />

<span class="comment-delimiter">;;; </span><span class="comment">Problem 7. 10001st Prime
</span><span class="comment-delimiter">;; </span><span class="comment">By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13,
</span><span class="comment-delimiter">;; </span><span class="comment">we can see that the 6th prime is 13.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">What is the 10001st prime number.
</span>
(<span class="keyword">defun</span> <span class="function-name">problem7</span> (<span class="type">&amp;optional</span> (nth 10001))
  <span class="doc">"Return the NTH prime number. "</span>
  (nth-prime nth))

<hr />
<span class="comment-delimiter">;;; </span><span class="comment">Problem 8. Largest Product in a Series
</span><span class="comment-delimiter">;; </span><span class="comment">The four adjacent digits in the 1000-digit number that have
</span><span class="comment-delimiter">;; </span><span class="comment">the greatest product are 9 * 9 * 8 * 9 = 5832.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">73167176531330624919225119674426574742355349194934
</span><span class="comment-delimiter">;; </span><span class="comment">96983520312774506326239578318016984801869478851843
</span><span class="comment-delimiter">;; </span><span class="comment">85861560789112949495459501737958331952853208805511
</span><span class="comment-delimiter">;; </span><span class="comment">12540698747158523863050715693290963295227443043557
</span><span class="comment-delimiter">;; </span><span class="comment">66896648950445244523161731856403098711121722383113
</span><span class="comment-delimiter">;; </span><span class="comment">62229893423380308135336276614282806444486645238749
</span><span class="comment-delimiter">;; </span><span class="comment">30358907296290491560440772390713810515859307960866
</span><span class="comment-delimiter">;; </span><span class="comment">70172427121883998797908792274921901699720888093776
</span><span class="comment-delimiter">;; </span><span class="comment">65727333001053367881220235421809751254540594752243
</span><span class="comment-delimiter">;; </span><span class="comment">52584907711670556013604839586446706324415722155397
</span><span class="comment-delimiter">;; </span><span class="comment">53697817977846174064955149290862569321978468622482
</span><span class="comment-delimiter">;; </span><span class="comment">83972241375657056057490261407972968652414535100474
</span><span class="comment-delimiter">;; </span><span class="comment">82166370484403199890008895243450658541227588666881
</span><span class="comment-delimiter">;; </span><span class="comment">16427171479924442928230863465674813919123162824586
</span><span class="comment-delimiter">;; </span><span class="comment">17866458359124566529476545682848912883142607690042
</span><span class="comment-delimiter">;; </span><span class="comment">24219022671055626321111109370544217506941658960408
</span><span class="comment-delimiter">;; </span><span class="comment">07198403850962455444362981230987879927244284909188
</span><span class="comment-delimiter">;; </span><span class="comment">84580156166097919133875499200524063689912560717606
</span><span class="comment-delimiter">;; </span><span class="comment">05886116467109405077541002256983155200055935729725
</span><span class="comment-delimiter">;; </span><span class="comment">71636269561882670428252483600823257530420752963450
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">Find the thirteen adjacent digits in the 1000-digit
</span><span class="comment-delimiter">;; </span><span class="comment">number that have the greatest product. What is the
</span><span class="comment-delimiter">;; </span><span class="comment">value of this product?
</span><span class="comment-delimiter">;;</span><span class="comment">
</span>
(<span class="keyword">defun</span> <span class="function-name">digit&lt;-digit-char</span> (char)
  <span class="doc">"Turn CHAR (#\0 to #\9) into integer number. "</span>
  (<span class="keyword">the</span> (integer 0 9) (- (char-code char) (char-code #\0))))

(<span class="keyword">defun</span> <span class="function-name">prod</span> (sequence)
  <span class="doc">"Return the products of SEQUENCE. "</span>
  (<span class="keyword">let</span> ((prod 1))
    (map nil (<span class="keyword">lambda</span> (x) (setf prod (* prod x))) sequence)
    prod))

(<span class="keyword">defun</span> <span class="function-name">problem8</span> (<span class="type">&amp;optional</span>
                 (len 13)
                 (digits (mapcar #'digit&lt;-digit-char
                                 (concatenate
                                  'list
                                  <span class="string">"73167176531330624919225119674426574742355349194934"</span>
                                  <span class="string">"96983520312774506326239578318016984801869478851843"</span>
                                  <span class="string">"85861560789112949495459501737958331952853208805511"</span>
                                  <span class="string">"12540698747158523863050715693290963295227443043557"</span>
                                  <span class="string">"66896648950445244523161731856403098711121722383113"</span>
                                  <span class="string">"62229893423380308135336276614282806444486645238749"</span>
                                  <span class="string">"30358907296290491560440772390713810515859307960866"</span>
                                  <span class="string">"70172427121883998797908792274921901699720888093776"</span>
                                  <span class="string">"65727333001053367881220235421809751254540594752243"</span>
                                  <span class="string">"52584907711670556013604839586446706324415722155397"</span>
                                  <span class="string">"53697817977846174064955149290862569321978468622482"</span>
                                  <span class="string">"83972241375657056057490261407972968652414535100474"</span>
                                  <span class="string">"82166370484403199890008895243450658541227588666881"</span>
                                  <span class="string">"16427171479924442928230863465674813919123162824586"</span>
                                  <span class="string">"17866458359124566529476545682848912883142607690042"</span>
                                  <span class="string">"24219022671055626321111109370544217506941658960408"</span>
                                  <span class="string">"07198403850962455444362981230987879927244284909188"</span>
                                  <span class="string">"84580156166097919133875499200524063689912560717606"</span>
                                  <span class="string">"05886116467109405077541002256983155200055935729725"</span>
                                  <span class="string">"71636269561882670428252483600823257530420752963450"</span>))))
  <span class="doc">"Find the greatest LEN digits. "</span>
  (reduce #'max (windowed-mapcar (compose #'prod #'args) len digits)))

<hr />

<span class="comment-delimiter">;;; </span><span class="comment">Problem 9. Special Pythagorean Triplet
</span><span class="comment-delimiter">;; </span><span class="comment">A Pythagorean triplet is a set of three natural numbers,
</span><span class="comment-delimiter">;; </span><span class="comment">a &lt; b &lt; c, for which,
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;;    </span><span class="comment">a^2 + b^2 = c^2
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">For example, 3^2 + 4^2 = 9 + 16 = 25 = 5^2.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">These exists exactly one Pythagorean triplet for which a + b + c = 1000.
</span><span class="comment-delimiter">;; </span><span class="comment">Find the product a * b * c.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span>
(<span class="keyword">defmacro</span> <span class="function-name">with-sorted3</span> ((a b c) <span class="type">&amp;body</span> body)
  <span class="doc">"Sort A, B, C and evaluate BODY. "</span>
  (<span class="keyword">with-gensym</span> (min mid max)
    `(<span class="keyword">let*</span> ((,min (min ,a ,b ,c))
            (,max (max ,a ,b ,c))
            (,mid (- (+ ,a ,b ,c) (+ ,min ,max)))
            (,a ,min)
            (,b ,mid)
            (,c ,max))
       ,@body)))

(<span class="keyword">defun</span> <span class="function-name">pythagoreanp</span> (a b c)
  <span class="doc">"Test if A, B, C is a set of Pythagorean number. "</span>
  (<span class="keyword">with-sorted3</span> (a b c)
    (= (+ (square a) (square b)) (square c))))

<span class="comment-delimiter">;; </span><span class="comment">a + b + c = 1000
</span><span class="comment-delimiter">;; </span><span class="comment">a^2 + b^2 = c^2
</span><span class="comment-delimiter">;; </span><span class="comment">=&gt; b = ((2 * a - n) * n) / (2 * (a - n))
</span>
(<span class="keyword">defun</span> <span class="function-name">problem9</span> (<span class="type">&amp;optional</span> (sum 1000))
  <span class="doc">"Find the Pythagorean a + b + c = 1000 and return a * b * c. "</span>
  (<span class="keyword">loop</span> for a from 1 upto (floor sum 2)
        for b1 = (* (- (* 2 a) sum) sum)
        for b2 = (* 2 (- a sum))
        if (modp b1 b2)
          return (<span class="keyword">let*</span> ((b (/ b1 b2))
                        (c (- sum a b)))
                   (* a b c))))

<hr />
<span class="comment-delimiter">;;; </span><span class="comment">Problem 10. Summation of Primes
</span><span class="comment-delimiter">;; </span><span class="comment">The sum of the primes below 10 is 2 + 3 + 5 + 7 = 17.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">Find the sum of all the primes below two million.
</span>
(<span class="keyword">defun</span> <span class="function-name">problem10</span> (<span class="type">&amp;optional</span> (max (* 2 +million+)))
  <span class="doc">"Find the sum of all the primes below MAX. "</span>
  (<span class="keyword">loop</span> for n from 2 below max
        if (primep n) sum n))

<hr />

<span class="comment-delimiter">;;; </span><span class="comment">Problem Largest Product in a Grid
</span><span class="comment-delimiter">;; </span><span class="comment">In the 20 * 20 grid below, what is the greatest product of
</span><span class="comment-delimiter">;; </span><span class="comment">four adjacent numbers in the same direction (up, down, left,
</span><span class="comment-delimiter">;; </span><span class="comment">right, or diagonally) in the 20x20 grid.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span>
(<span class="keyword">defun</span> <span class="function-name">grid-lr</span> (grid i j <span class="type">&amp;optional</span> (len 4))
  <span class="doc">"Return a list of GRID element starting at I, J
of length LEN at direction LR. "</span>
  (<span class="keyword">declare</span> (type (array t 2) grid)
           (type unsigned-byte i j len))
  (<span class="keyword">destructuring-bind</span> (imax jmax) (array-dimensions grid)
    (<span class="warning">assert</span> (and (&lt;= 0 i) (&lt; i (- imax len))
                 (&lt;= 0 j) (&lt; j jmax)))
    (<span class="keyword">loop</span> for ii from i below (+ i len)
          collect (aref grid ii j))))

(<span class="keyword">defun</span> <span class="function-name">grid-ud</span> (grid i j <span class="type">&amp;optional</span> (len 4))
  <span class="doc">"Return a list of GRID element starting at I, J
of length LEN at direction UD. "</span>
  (<span class="keyword">declare</span> (type (array t 2) grid)
           (type unsigned-byte i j len))
  (<span class="keyword">destructuring-bind</span> (imax jmax) (array-dimensions grid)
    (<span class="warning">assert</span> (and (&lt;= 0 i) (&lt; i imax)
                 (&lt;= 0 j) (&lt; j (- jmax len))))
    (<span class="keyword">loop</span> for jj from j below (+ j len)
          collect (aref grid i jj))))

(<span class="keyword">defun</span> <span class="function-name">grid-trig</span> (grid i j <span class="type">&amp;optional</span> (len 4))
  <span class="doc">"Return a list of GRID element starting at I, J
of length LEN at direction diagonally. "</span>
  (<span class="keyword">declare</span> (type (array t 2) grid)
           (type unsigned-byte i j len))
  (<span class="keyword">destructuring-bind</span> (imax jmax) (array-dimensions grid)
    (<span class="warning">assert</span> (and (&lt;= 0 i) (&lt; i (- imax len))
                 (&lt;= 0 j) (&lt; j (- jmax len))))
    (<span class="keyword">loop</span> for ii from i below (+ i len)
          for jj from j below (+ j len)
          collect (aref grid ii jj))))

(<span class="keyword">defun</span> <span class="function-name">problem11</span> (<span class="type">&amp;optional</span> (len 4) (grid
                                     #2A((01 70 54 71 83 51 54 69 16 92 33 48 61 43 52 01 89 19 67 48)
                                         (20 73 35 29 78 31 90 01 74 31 49 71 48 86 81 16 23 57 05 54)
                                         (20 69 36 41 72 30 23 88 34 62 99 69 82 67 59 85 74 04 36 16)
                                         (04 42 16 73 38 25 39 11 24 94 72 18 08 46 29 32 40 62 76 36)
                                         (88 36 68 87 57 62 20 72 03 46 33 67 46 55 12 32 63 93 53 69)
                                         (04 52 08 83 97 35 99 16 07 97 57 32 16 26 26 79 33 27 98 66)
                                         (19 80 81 68 05 94 47 69 28 73 92 13 86 52 17 77 04 89 55 40)
                                         (86 56 00 48 35 71 89 07 05 44 44 37 44 60 21 58 51 54 17 58)
                                         (16 39 05 42 96 35 31 47 55 58 88 24 00 17 54 24 36 29 85 57)
                                         (78 17 53 28 22 75 31 67 15 94 03 80 04 62 16 14 09 53 56 92)
                                         (21 36 23 09 75 00 76 44 20 45 35 14 00 61 33 97 34 31 33 95)
                                         (24 55 58 05 66 73 99 26 97 17 78 78 96 83 14 88 34 89 63 72)
                                         (67 26 20 68 02 62 12 20 95 63 94 39 63 08 40 91 66 49 94 21)
                                         (32 98 81 28 64 23 67 10 26 38 40 67 59 54 70 66 18 38 64 70)
                                         (24 47 32 60 99 03 45 02 44 75 33 53 78 36 84 20 35 17 12 50)
                                         (22 31 16 71 51 67 63 89 41 92 36 54 22 40 40 28 66 33 13 80)
                                         (52 70 95 23 04 60 11 42 69 24 68 56 01 32 56 71 37 02 36 91)
                                         (81 49 31 73 55 79 14 29 93 71 40 67 53 88 30 03 49 13 36 65)
                                         (49 49 99 40 17 81 18 57 60 87 17 40 98 43 69 48 04 56 62 00)
                                         (08 02 22 97 38 15 00 40 00 75 04 05 07 78 52 12 50 77 91 08))))
  <span class="doc">"Return the greatest product of four adjacent numbers. "</span>
  (<span class="keyword">let</span> ((prod 0))
    (<span class="keyword">destructuring-bind</span> (imax jmax) (array-dimensions grid)
      (<span class="keyword">loop</span> for i from 0 below (- imax len) do
        (<span class="keyword">loop</span> for j from 0 below (- jmax len) do
          (setf prod (max prod
                          (prod (grid-lr   grid i j len))
                          (prod (grid-ud   grid i j len))
                          (prod (grid-trig grid i j len)))))))
    prod))

<hr />

<span class="comment-delimiter">;;; </span><span class="comment">Problem 12. Highly Divisible Triangular Number
</span><span class="comment-delimiter">;; </span><span class="comment">The sequence of triangle numbers is generated by adding the natural
</span><span class="comment-delimiter">;; </span><span class="comment">numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28.
</span><span class="comment-delimiter">;; </span><span class="comment">The first ten terms would be:
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;;     </span><span class="comment">1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">Let us list the factors of the first seven triangle numbers:
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;;         </span><span class="comment">1: 1
</span><span class="comment-delimiter">;;         </span><span class="comment">3: 1, 3
</span><span class="comment-delimiter">;;         </span><span class="comment">6: 1, 2, 3, 6
</span><span class="comment-delimiter">;;        </span><span class="comment">10: 1, 2, 5, 10
</span><span class="comment-delimiter">;;        </span><span class="comment">15: 1, 3, 5, 15
</span><span class="comment-delimiter">;;        </span><span class="comment">21: 1, 3, 7, 21
</span><span class="comment-delimiter">;;        </span><span class="comment">28: 1, 2, 4, 7, 14, 28
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">We can see that 28 is the first triangle number to have over five
</span><span class="comment-delimiter">;; </span><span class="comment">divisors.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">What is the value of the first triangle number to have over five
</span><span class="comment-delimiter">;; </span><span class="comment">hundred divisors.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span>
<span class="comment-delimiter">;; </span><span class="comment">Algorithm:
</span><span class="comment-delimiter">;; </span><span class="comment">divisors(1)     = (1)
</span><span class="comment-delimiter">;; </span><span class="comment">divisors(n * p^m) = (append
</span><span class="comment-delimiter">;;                       </span><span class="comment">(mapcar (curry #'* p^0) divisors(n))
</span><span class="comment-delimiter">;;                       </span><span class="comment">(mapcar (curry #'* p^1) divisors(n))
</span><span class="comment-delimiter">;;                       </span><span class="comment">(mapcar (curry #'* p^2) divisors(n))
</span><span class="comment-delimiter">;;                       </span><span class="comment">...)
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">Note that all number could be splited as n = p1^n1 * p2^n2 ...,
</span><span class="comment-delimiter">;; </span><span class="comment">so this procedure is terminatable.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span>
(<span class="keyword">defun</span> <span class="function-name">divisors</span> (n)
  <span class="doc">"Return a list of divisors of N. "</span>
  (<span class="keyword">declare</span> (type unsigned-byte n))
  (<span class="keyword">loop</span> for divisors = '(1) then (apply #'append (cons divisors mul))
        for (factor . order) in (factors n)
        for mul = (<span class="keyword">loop</span> for i from 1 upto order
                        collect (mapcar (curry #'* (expt factor i)) divisors))
        finally (<span class="keyword">return</span> divisors)))

(<span class="keyword">defun</span> <span class="function-name">problem12</span> (<span class="type">&amp;optional</span> (max 500))
  <span class="doc">"Return the value of the first triangle number to have over MAX divisors. "</span>
  (<span class="keyword">loop</span> for i from 1
        for trig = (* (+ 1 i) i 1/2)
        if (&gt; (length (divisors trig)) max)
          return trig))

<span class="comment-delimiter">;; </span><span class="comment">a faster implementation of (length (divisors n))
</span>
<span class="comment-delimiter">;; </span><span class="comment">Notice that for n = p1^n1 * p2^n2 * ..., any number
</span><span class="comment-delimiter">;; </span><span class="comment">n' = p1^n1' * p2^n2' * ..., (n1' &lt;= n1, n2' &lt;= n2, ...)
</span><span class="comment-delimiter">;; </span><span class="comment">can divide n. (aka. (modp n n') is true).
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">So the number of dividors of n can be calculated by:
</span><span class="comment-delimiter">;; </span><span class="comment">(1 + n1) * (1 + n2) * ...
</span><span class="comment-delimiter">;;</span><span class="comment">
</span>
(<span class="keyword">defun</span> <span class="function-name">count-divisors</span> (n)
  <span class="doc">"Return the number of N divisors. "</span>
  (prod (mapcar (compose #'1+ #'cdr) (factors n))))

(<span class="keyword">defun</span> <span class="function-name">problem12-faster</span> (<span class="type">&amp;optional</span> (max 500))
  <span class="doc">"Return the value of the first triangle number to have over MAX divisors. "</span>
  (<span class="keyword">loop</span> for i from 1
        for trig = (* (+ 1 i) i 1/2)
        if (&gt; (count-divisors trig) max)
          return trig))

<hr />
<span class="comment-delimiter">;;; </span><span class="comment">Problem 13. Large Sum
</span><span class="comment-delimiter">;; </span><span class="comment">Work out the first ten digits of the sum of the following 50 digits numbers.
</span>
(<span class="keyword">defun</span> <span class="function-name">int&lt;-p-digits</span> (digits <span class="type">&amp;optional</span> (base 10))
  <span class="doc">"Return integer of DIGITS of BASE. "</span>
  (<span class="keyword">loop</span> with int = 0
        for digit in digits
        do (setf int (+ (* base int) digit))
        finally (<span class="keyword">return</span> int)))

(<span class="keyword">defun</span> <span class="function-name">problem13</span> (<span class="type">&amp;optional</span> (n 10) (digits
                                    '(37107287533902102798797998220837590246510135740250
                                      46376937677490009712648124896970078050417018260538
                                      74324986199524741059474233309513058123726617309629
                                      91942213363574161572522430563301811072406154908250
                                      23067588207539346171171980310421047513778063246676
                                      89261670696623633820136378418383684178734361726757
                                      28112879812849979408065481931592621691275889832738
                                      44274228917432520321923589422876796487670272189318
                                      47451445736001306439091167216856844588711603153276
                                      70386486105843025439939619828917593665686757934951
                                      62176457141856560629502157223196586755079324193331
                                      64906352462741904929101432445813822663347944758178
                                      92575867718337217661963751590579239728245598838407
                                      58203565325359399008402633568948830189458628227828
                                      80181199384826282014278194139940567587151170094390
                                      35398664372827112653829987240784473053190104293586
                                      86515506006295864861532075273371959191420517255829
                                      71693888707715466499115593487603532921714970056938
                                      54370070576826684624621495650076471787294438377604
                                      53282654108756828443191190634694037855217779295145
                                      36123272525000296071075082563815656710885258350721
                                      45876576172410976447339110607218265236877223636045
                                      17423706905851860660448207621209813287860733969412
                                      81142660418086830619328460811191061556940512689692
                                      51934325451728388641918047049293215058642563049483
                                      62467221648435076201727918039944693004732956340691
                                      15732444386908125794514089057706229429197107928209
                                      55037687525678773091862540744969844508330393682126
                                      18336384825330154686196124348767681297534375946515
                                      80386287592878490201521685554828717201219257766954
                                      78182833757993103614740356856449095527097864797581
                                      16726320100436897842553539920931837441497806860984
                                      48403098129077791799088218795327364475675590848030
                                      87086987551392711854517078544161852424320693150332
                                      59959406895756536782107074926966537676326235447210
                                      69793950679652694742597709739166693763042633987085
                                      41052684708299085211399427365734116182760315001271
                                      65378607361501080857009149939512557028198746004375
                                      35829035317434717326932123578154982629742552737307
                                      94953759765105305946966067683156574377167401875275
                                      88902802571733229619176668713819931811048770190271
                                      25267680276078003013678680992525463401061632866526
                                      36270218540497705585629946580636237993140746255962
                                      24074486908231174977792365466257246923322810917141
                                      91430288197103288597806669760892938638285025333403
                                      34413065578016127815921815005561868836468420090470
                                      23053081172816430487623791969842487255036638784583
                                      11487696932154902810424020138335124462181441773470
                                      63783299490636259666498587618221225225512486764533
                                      67720186971698544312419572409913959008952310058822
                                      95548255300263520781532296796249481641953868218774
                                      76085327132285723110424803456124867697064507995236
                                      37774242535411291684276865538926205024910326572967
                                      23701913275725675285653248258265463092207058596522
                                      29798860272258331913126375147341994889534765745501
                                      18495701454879288984856827726077713721403798879715
                                      38298203783031473527721580348144513491373226651381
                                      34829543829199918180278916522431027392251122869539
                                      40957953066405232632538044100059654939159879593635
                                      29746152185502371307642255121183693803580388584903
                                      41698116222072977186158236678424689157993532961922
                                      62467957194401269043877107275048102390895523597457
                                      23189706772547915061505504953922979530901129967519
                                      86188088225875314529584099251203829009407770775672
                                      11306739708304724483816533873502340845647058077308
                                      82959174767140363198008187129011875491310547126581
                                      97623331044818386269515456334926366572897563400500
                                      42846280183517070527831839425882145521227251250327
                                      55121603546981200581762165212827652751691296897789
                                      32238195734329339946437501907836945765883352399886
                                      75506164965184775180738168837861091527357929701337
                                      62177842752192623401942399639168044983993173312731
                                      32924185707147349566916674687634660915035914677504
                                      99518671430235219628894890102423325116913619626622
                                      73267460800591547471830798392868535206946944540724
                                      76841822524674417161514036427982273348055556214818
                                      97142617910342598647204516893989422179826088076852
                                      87783646182799346313767754307809363333018982642090
                                      10848802521674670883215120185883543223812876952786
                                      71329612474782464538636993009049310363619763878039
                                      62184073572399794223406235393808339651327408011116
                                      66627891981488087797941876876144230030984490851411
                                      60661826293682836764744779239180335110989069790714
                                      85786944089552990653640447425576083659976645795096
                                      66024396409905389607120198219976047599490197230297
                                      64913982680032973156037120041377903785566085089252
                                      16730939319872750275468906903707539413042652315011
                                      94809377245048795150954100921645863754710598436791
                                      78639167021187492431995700641917969777599028300699
                                      15368713711936614952811305876380278410754449733078
                                      40789923115535562561142322423255033685442488917353
                                      44889911501440648020369068063960672322193204149535
                                      41503128880339536053299340368006977710650566631954
                                      81234880673210146739058568557934581403627822703280
                                      82616570773948327592232845941706525094512325230608
                                      22918802058777319719839450180888072429661980811197
                                      77158542502016545090413245809786882778948721859617
                                      72107838435069186155435662884062257473692284509516
                                      20849603980134001723930671666823555245252804609722
                                      53503534226472524250874054075591789781264330331690)))
  <span class="doc">"Return the first N digits. "</span>
  (int&lt;-p-digits (subseq (p-digits (sum digits)) 0 n)))

<hr />
<span class="comment-delimiter">;;; </span><span class="comment">Problem 14. Longest Collatz Sequence
</span><span class="comment-delimiter">;; </span><span class="comment">The following iterative sequence is defined for the set of
</span><span class="comment-delimiter">;; </span><span class="comment">positive integers:
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;;   </span><span class="comment">n -&gt; n / 2     (n is even)
</span><span class="comment-delimiter">;;   </span><span class="comment">n -&gt; 3 * n + 1 (n is odd)
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">Using the rule above and starting with 13, we generate the following
</span><span class="comment-delimiter">;; </span><span class="comment">sequence:
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;;   </span><span class="comment">13 -&gt; 40 -&gt; 20 -&gt; 10 -&gt; 5 -&gt; 16 -&gt; 8 -&gt; 4 -&gt; 2 -&gt; 1
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">It can be seen that this sequence (starting at 13 and finishing at 1)
</span><span class="comment-delimiter">;; </span><span class="comment">contains 10 terms.
</span><span class="comment-delimiter">;; </span><span class="comment">Although it has not been proved yet (Collatz Problem), it is thought
</span><span class="comment-delimiter">;; </span><span class="comment">that all starting numbers finish at 1.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">Which starting number under one million, produces the longest chain?
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">NOTE: Once the chain starts the terms are allowed to go above one
</span><span class="comment-delimiter">;; </span><span class="comment">million.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span>
(<span class="keyword">defun</span> <span class="function-name">collatz-next</span> (start)
  <span class="doc">"Return next of START of Collatz sequence. "</span>
  (<span class="keyword">if</span> (evenp start)
      (/ start 2)
      (1+ (* 3 start))))

(defun-cached collatz-list (start)
  <span class="string">"Return a Collatz List starting from START. "</span>
  (<span class="keyword">if</span> (= start 1) '(1)
      (cons start (collatz-list (collatz-next start)))))

(defun-cached count-collatz-list (start)
  <span class="string">"Return the length of Collatz List starting from START. "</span>
  (<span class="keyword">if</span> (= start 1) 1 (1+ (count-collatz-list (collatz-next start)))))

(<span class="keyword">defun</span> <span class="function-name">problem14</span> (<span class="type">&amp;optional</span> (lim (* 1 +million+)))
  <span class="doc">"Return the number below LIM of the longest Collatrz list. "</span>
  (<span class="keyword">loop</span> with start = 1
        with max   = 1
        for i from 1 below lim
        for cnt = (count-collatz-list i)
        if (&gt; cnt max)
          do (setf max   cnt
                   start i)
        finally (<span class="keyword">return</span> start)))

<hr />
<span class="comment-delimiter">;;; </span><span class="comment">Problem 15. Lattice Paths
</span><span class="comment-delimiter">;; </span><span class="comment">Starting in the top left corner of a 2x2 grid, and only being
</span><span class="comment-delimiter">;; </span><span class="comment">able to move to the right and down, there are exactly 6 routes
</span><span class="comment-delimiter">;; </span><span class="comment">to the bottom right corner.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span>
(<span class="keyword">defmacro</span> <span class="function-name">at</span> (grid <span class="type">&amp;rest</span> indexs)
  <span class="doc">"Get element of GRID by INDEXS.

Example:

    (at grid x)
    (at grid x y)
    (at grid x y z)

"</span>
  `(aref ,grid ,@(reverse indexs)))

<span class="comment-delimiter">;; </span><span class="comment">The path length is:
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;;    </span><span class="comment">(path i j) = (+ (path (1+ i) j) (path i (1+ j)))
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">use `cache` to acclerate iteration
</span>
(<span class="keyword">defun</span> <span class="function-name">problem15</span> (<span class="type">&amp;optional</span> (w 20) (h 20))
  <span class="doc">"Return the counts of routes through a WxH grid. "</span>
  (<span class="keyword">let</span> ((cache (make-array (list (1+ h) (1+ w)) <span class="builtin">:initial-element</span> -1)))
    (setf (at cache w h) 1)
    (<span class="keyword">labels</span> ((path (i j)
               (<span class="keyword">if</span> (&gt;= (at cache i j) 0)
                   (at cache i j)
                   (setf (at cache i j)
                         (+ (<span class="keyword">if</span> (= i w) 0
                                (path (1+ i) j))
                            (<span class="keyword">if</span> (= j h) 0
                                (path i (1+ j))))))))
      (path 0 0))))

<hr />
<span class="comment-delimiter">;;; </span><span class="comment">Problem 16. Power Digit Sum
</span><span class="comment-delimiter">;; </span><span class="comment">2^15 = 32768 and the sum of its digits is 3 + 2 + 7 + 6 + 8 = 26.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">What is the sum of the digits of the number 2^1000?
</span><span class="comment-delimiter">;;</span><span class="comment">
</span>
(<span class="keyword">defun</span> <span class="function-name">problem16</span> (<span class="type">&amp;optional</span> (exp 1000))
  (sum (p-digits (expt 2 exp))))

<hr />
<span class="comment-delimiter">;;; </span><span class="comment">Problem 17. Number Letter Counts
</span><span class="comment-delimiter">;; </span><span class="comment">If the numbers 1 to 5 are written out in words: one, two, three,
</span><span class="comment-delimiter">;; </span><span class="comment">four, five, then there are 3 + 3 + 5 + 4 + 4 = 19 letters used in total.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">If all the numbers from 1 to 1000 (one thousand) inclusive were
</span><span class="comment-delimiter">;; </span><span class="comment">written out in words, how many letters would be used?
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">Note: Do not count spaces or hyphens.
</span><span class="comment-delimiter">;; </span><span class="comment">For example, 342 (three hundred and forty-two) contains 23 leters
</span><span class="comment-delimiter">;; </span><span class="comment">and 115 (one hundred and fifteen) contains 20 letters.
</span><span class="comment-delimiter">;; </span><span class="comment">The use of "and" when writing out numbers is in compliance with
</span><span class="comment-delimiter">;; </span><span class="comment">British usage.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span>
(<span class="keyword">defun</span> <span class="function-name">constr</span> (<span class="type">&amp;rest</span> sequences)
  <span class="doc">"Merge SEQUENCES as a string. "</span>
  (apply #'concatenate 'string sequences))

(<span class="keyword">defun</span> <span class="function-name">number&lt;100-to-words</span> (number)
  <span class="doc">"Turn NUMBER (&lt; 100) as english words. "</span>
  (<span class="keyword">declare</span> (type unsigned-byte number))
  (<span class="warning">assert</span> (&lt;= 0 number 99))
  (<span class="keyword">let</span> ((map10 #(<span class="string">""</span> <span class="string">""</span> <span class="string">"twenty"</span> <span class="string">"thirty"</span> <span class="string">"forty"</span> <span class="string">"fifty"</span> <span class="string">"sixty"</span> <span class="string">"seventy"</span> <span class="string">"eighty"</span> <span class="string">"ninety"</span>))
        (map1  #(<span class="string">"zero"</span> <span class="string">"one"</span> <span class="string">"two"</span> <span class="string">"three"</span> <span class="string">"four"</span> <span class="string">"five"</span> <span class="string">"six"</span> <span class="string">"seven"</span> <span class="string">"eight"</span> <span class="string">"nine"</span>
                 <span class="string">"ten"</span> <span class="string">"eleven"</span> <span class="string">"twelve"</span> <span class="string">"thirteen"</span> <span class="string">"fourteen"</span> <span class="string">"fifteen"</span> <span class="string">"sixteen"</span>
                 <span class="string">"seventeen"</span> <span class="string">"eighteen"</span> <span class="string">"nineteen"</span>)))
    (<span class="keyword">if</span> (&lt; number 20)
        (aref map1 number)
        (<span class="keyword">let</span> ((d10 (floor (/ number 10)))
              (d1  (mod number 10)))
          (constr (aref map10 d10) <span class="string">"-"</span> (aref map1 d1))))))

(<span class="keyword">defun</span> <span class="function-name">number&lt;1000-to-words</span> (number)
  <span class="doc">"Turn NUMBER (&lt; 1000) as english words. "</span>
  (<span class="keyword">declare</span> (type unsigned-byte number))
  (<span class="warning">assert</span> (&lt;= 0 number 999))
  (<span class="keyword">let</span> ((map1 #(<span class="string">"zero"</span> <span class="string">"one"</span> <span class="string">"two"</span> <span class="string">"three"</span> <span class="string">"four"</span> <span class="string">"five"</span> <span class="string">"six"</span> <span class="string">"seven"</span> <span class="string">"eight"</span> <span class="string">"nine"</span>)))
    (<span class="keyword">let</span> ((d100 (floor (/ number 100)))
          (d10  (mod number 100)))
      (<span class="keyword">cond</span> ((zerop d100) (number&lt;100-to-words d10))
            ((zerop d10)  (constr (aref map1 d100) <span class="string">" hundred"</span>))
            (t (constr (aref map1 d100) <span class="string">" hundred and "</span> (number&lt;100-to-words d10)))))))

(<span class="keyword">defun</span> <span class="function-name">number-to-words</span> (number)
  <span class="doc">"Turn NUMBER as english words. "</span>
  (<span class="keyword">let</span> ((map1000 #(nil <span class="string">"thousand"</span> <span class="string">"million"</span> <span class="string">"billion"</span> <span class="string">"trillion"</span>
                   <span class="string">"quadrillion"</span>  <span class="string">"quintillion"</span>       <span class="string">"sextillion"</span>
                   <span class="string">"septillion"</span>   <span class="string">"octillion"</span>         <span class="string">"nonillion"</span>
                   <span class="string">"decillion"</span>    <span class="string">"undecillion"</span>       <span class="string">"duodecillion"</span>
                   <span class="string">"tredecillion"</span> <span class="string">"quattuordecillion"</span> <span class="string">"quindecillion"</span>
                   <span class="string">"sexdecillion"</span> <span class="string">"septendecillion"</span>   <span class="string">"octodecillion"</span>))
        (digits  (p-digits number 1000)))
    (<span class="keyword">if</span> (zerop number) <span class="string">"zero"</span>
        (<span class="keyword">loop</span> for i from (- (length digits) 1) downto 0
              for digit in digits
              for unit = (aref map1000 i)
              if (not (zerop digit))
                collect (<span class="keyword">if</span> unit
                            (constr (number&lt;1000-to-words digit) <span class="string">" "</span> unit)
                            (number&lt;1000-to-words digit))
                  into words
              finally (<span class="keyword">return</span> (format nil <span class="string">"~{~A~^ ~}"</span> words))))))

(<span class="keyword">defun</span> <span class="function-name">count-letters</span> (string)
  <span class="doc">"Count letters in STRING. "</span>
  (<span class="keyword">let</span> ((count 0))
    (<span class="keyword">dotimes</span> (i (length string) count)
      (<span class="keyword">let</span> ((c (aref string i)))
        (<span class="keyword">when</span> (or (char&lt;= #\A c #\Z) (char&lt;= #\a c #\z))
          (incf count))))))

(<span class="keyword">defun</span> <span class="function-name">problem17</span> (<span class="type">&amp;optional</span> (max 1000))
  <span class="doc">"Return the number of letters of words. "</span>
  (<span class="keyword">loop</span> for i from 1 upto max sum (count-letters (number-to-words i))))

<hr />
<span class="comment-delimiter">;;; </span><span class="comment">Problem 18. Maximum Path Sum I
</span><span class="comment-delimiter">;; </span><span class="comment">By starting at the top of the triangle below and moving to adjacent
</span><span class="comment-delimiter">;; </span><span class="comment">numbers on the row below, the maximum total from top to bottom is 23.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;;                </span><span class="comment">*3*
</span><span class="comment-delimiter">;;              </span><span class="comment">*7*  4
</span><span class="comment-delimiter">;;             </span><span class="comment">2  *4*  6
</span><span class="comment-delimiter">;;           </span><span class="comment">8  5  *9*  3
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">That is, 3 + 7 + 4 + 9 = 23.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">Find the maximum total from top to bottom of the triangle below:
</span><span class="comment-delimiter">;;</span><span class="comment">
</span>
<span class="comment-delimiter">;; </span><span class="comment">To solve this, just calculate them all and using the array as cache.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;;     </span><span class="comment">(path-length layer i) &lt;= (max (trig (1+ layer) i) (trig (1+ layer) (1+ i)))
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">So going from bottom to top, thus the result can reduced.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span>
(<span class="keyword">defun</span> <span class="function-name">problem18</span> (<span class="type">&amp;optional</span> (trig '((75)
                                    (95 64)
                                    (17 47 82)
                                    (18 35 87 10)
                                    (20 04 82 47 65)
                                    (19 01 23 75 03 34)
                                    (88 02 77 73 07 63 67)
                                    (99 65 04 28 06 16 70 92)
                                    (41 41 26 56 83 40 80 70 33)
                                    (41 48 72 33 47 32 37 16 94 29)
                                    (53 71 44 65 25 43 91 52 97 51 14)
                                    (70 11 33 28 77 73 17 78 39 68 17 57)
                                    (91 71 52 38 17 14 91 43 58 50 27 29 48)
                                    (63 66 04 68 89 53 67 30 73 16 69 87 40 31)
                                    (04 62 98 27 23 09 70 98 73 93 38 53 60 04 23))))
  (<span class="keyword">destructuring-bind</span> (first . rest) (reverse trig)
    (car (reduce (<span class="keyword">lambda</span> (path row)
                   (<span class="keyword">loop</span> for (i i+1) on path by #'cdr
                         for ti in row
                         collect (+ ti (max i i+1))))
                 rest
                 <span class="builtin">:initial-value</span> first))))

<hr />
<span class="comment-delimiter">;;; </span><span class="comment">Problem 19. Counting Sundays
</span><span class="comment-delimiter">;; </span><span class="comment">How many Sunday fell on the first of the month during the twentieth
</span><span class="comment-delimiter">;; </span><span class="comment">century (1 Jan 1901 to 31 Dec 2000)
</span><span class="comment-delimiter">;;</span><span class="comment">
</span>
(<span class="keyword">deftype</span> <span class="type">month</span> () '(integer 1 12))
(<span class="keyword">deftype</span> <span class="type">day</span>   () '(integer 1 31))

(<span class="keyword">defstruct</span> <span class="type">date</span>
  (year  0 <span class="builtin">:type</span> integer)
  (month 1 <span class="builtin">:type</span> month)
  (day   1 <span class="builtin">:type</span> day))

(defun-inline leap-year-p (date)
  <span class="string">"Test if DATE is leap year. "</span>
  (<span class="keyword">let</span> ((year (date-year date)))
    (and (modp year 4)
         (or (not (modp year 100))
             (modp year 400)))))

(<span class="keyword">defun</span> <span class="function-name">days-of-month</span> (date)
  <span class="doc">"Return the number of days in DATE month. "</span>
  <span class="comment-delimiter">;;                       </span><span class="comment">1  2  3  4  5  6  7  8  9  10 11 12
</span>  (<span class="keyword">let</span> ((day-of-month #(0 31 28 31 30 31 30 31 31 30 31 30 31)))
    (+ (aref day-of-month (date-month date))
       (<span class="keyword">if</span> (and (= (date-month date) 2) (leap-year-p date)) 1 0))))

(<span class="keyword">defun</span> <span class="function-name">next-day</span> (date)
  <span class="doc">"Return the day next DATE. "</span>
  (<span class="keyword">declare</span> (type date date))
  (<span class="keyword">let</span> ((days  (days-of-month date))
        (day   (date-day   date))
        (month (date-month date))
        (year  (date-year  date)))
    (<span class="keyword">when</span> (&gt; (incf day) days)
      (setf day 1)
      (<span class="keyword">when</span> (&gt; (incf month) 12)
        (setf month 1)
        (incf year)))
    (make-date <span class="builtin">:year</span> year <span class="builtin">:month</span> month <span class="builtin">:day</span> day)))

(<span class="keyword">defun</span> <span class="function-name">date</span> (year month day)
  <span class="doc">"Make a date YEAR MONTH DAY. "</span>
  (make-date <span class="builtin">:year</span> year <span class="builtin">:month</span> month <span class="builtin">:day</span> day))

<span class="comment-delimiter">;; </span><span class="comment">Sakamoto's methods
</span><span class="comment-delimiter">;; </span><span class="comment">cite: https://en.wikipedia.org/wiki/Determination_of_the_day_of_the_week#Sakamoto's_methods
</span>(<span class="keyword">defun</span> <span class="function-name">week-of-day</span> (date)
  <span class="doc">"Return the week of DATE. "</span>
  (<span class="keyword">let</span> ((week #(<span class="builtin">:sunday</span> <span class="builtin">:monday</span> <span class="builtin">:tuesday</span> <span class="builtin">:wednesday</span> <span class="builtin">:thursday</span> <span class="builtin">:friday</span> <span class="builtin">:saturday</span>))
        (dt   #(0 3 2 5 0 3 5 1 4 6 2 4)))
    (<span class="keyword">flet</span> ((/* (a b) (truncate a b)))
      (<span class="keyword">let*</span> ((m (date-month date))
             (y (<span class="keyword">if</span> (&lt; m 3)
                    (1- (date-year date))
                    (date-year date)))
             (d (date-day date)))
        (aref week (mod (+ y (/* y 4) (/* y -100) (/* y 400) (aref dt (1- m)) d) 7))))))

(<span class="keyword">defmethod</span> <span class="function-name">print-object</span> ((date date) stream)
  (format stream
          <span class="string">"~4,'0D-~2,'0D-~2,'0D ~A"</span>
          (date-year  date)
          (date-month date)
          (date-day   date)
          (week-of-day date)))

(<span class="keyword">defun</span> <span class="function-name">date=</span> (date1 date2)
  <span class="doc">"Test if DATE1 and DATE2 is same day. "</span>
  (and (= (date-year  date1) (date-year  date2))
       (= (date-month date1) (date-month date2))
       (= (date-day   date1) (date-day   date2))))

(<span class="keyword">defun</span> <span class="function-name">date&lt;</span> (date1 date2)
  <span class="doc">"Test if DATE1 is earlier than DATE2. "</span>
  (<span class="keyword">declare</span> (type date date1 date2))
  (<span class="keyword">if</span> (= (date-year date1) (date-year date2))
      (<span class="keyword">if</span> (= (date-month date1) (date-month date2))
          (&lt; (date-day date1) (date-day date2))
          (&lt; (date-month date1) (date-month date2)))
      (&lt; (date-year date1) (date-year date2))))

(<span class="keyword">defun</span> <span class="function-name">date&lt;=</span> (date1 date2)
  <span class="doc">"Test if DATE1 is eariler or equal to DATE2. "</span>
  (<span class="keyword">declare</span> (type date date1 date2))
  (or (date&lt; date1 date2) (date= date1 date2)))

(<span class="keyword">defun</span> <span class="function-name">problem19</span> (<span class="type">&amp;key</span> (start (date 1901 1 1)) (end (date 2000 12 31)) (day <span class="builtin">:sunday</span>))
  <span class="doc">"Count how many DAY fall on first month during START and END. "</span>
  (<span class="keyword">loop</span> for today = start then (next-day today)
        while (date&lt;= today end)
        count (and (= (date-day today) 1) (eq (week-of-day today) day))))

<hr />
<span class="comment-delimiter">;;; </span><span class="comment">Problem 20. Factorial Digit Sum
</span><span class="comment-delimiter">;; </span><span class="comment">n! means n * (n - 1) * ... * 3 * 2 * 1.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">For example, 10! = 10 * 9 * ... * 3 * 2 * 1 = 3628800,
</span><span class="comment-delimiter">;; </span><span class="comment">and the sume of the digits in the number 10! is 3 + 6 + 2 + 8 + 8 + 0 + 0 = 27.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">Find the sum of the digits in the number 100!.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span>
(<span class="keyword">defun</span> <span class="function-name">factorial</span> (n)
  <span class="doc">"Return N!. "</span>
  (<span class="keyword">loop</span> with fact = 1
        for i from 1 upto n
        do (setf fact (* fact i))
        finally (<span class="keyword">return</span> fact)))

(<span class="keyword">defun</span> <span class="function-name">problem20</span> (<span class="type">&amp;optional</span> (n 100))
  <span class="doc">"Return the sum of the digits of N!. "</span>
  (sum (p-digits (factorial n))))

<hr />
<span class="comment-delimiter">;;; </span><span class="comment">Problem 21. Amicable Numbers
</span><span class="comment-delimiter">;; </span><span class="comment">Let d(n) be defined as the sum of proper divisors of n (numbers less than
</span><span class="comment-delimiter">;; </span><span class="comment">n which divide evenly into n). If d(a) = b and d(b) = a, where a != b,
</span><span class="comment-delimiter">;; </span><span class="comment">then a and be are amicable pair and each of a and b are called amicable
</span><span class="comment-delimiter">;; </span><span class="comment">numbers.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">For example, the proper divisors of 220 are 1, 2, 4, 5, 10, 11, 20,
</span><span class="comment-delimiter">;; </span><span class="comment">22, 44, 55 and 100; therefore d(220) = 284. The proper divisors of 284
</span><span class="comment-delimiter">;; </span><span class="comment">are 1, 2, 4, 71 and 142; so d(284) = 220.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">Evaluate the sum of all the amicable numbers under 10000.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span>
(<span class="keyword">defun</span> <span class="function-name">problem21</span> (<span class="type">&amp;optional</span> (max 10000))
  <span class="doc">"Return the sum of all the amicable numbers under MAX. "</span>
  (<span class="keyword">let</span> ((d (make-array (1+ max)))
        (a ()))
    <span class="comment-delimiter">;; </span><span class="comment">calculate d(n) and store them to array `</span><span class="comment"><span class="constant">d</span></span><span class="comment">'
</span>    (<span class="keyword">loop</span> for n from 1 below max do
      (setf (aref d n) (- (sum (divisors n)) n)))
    <span class="comment-delimiter">;; </span><span class="comment">search for the d(d(a)) = a
</span>    (<span class="keyword">flet</span> ((d (x) (<span class="keyword">if</span> (or (&lt; x 0) (&gt; x max)) -1 (aref d x))))
      (<span class="keyword">loop</span> for n from 1 below max do
        (<span class="keyword">when</span> (and (= (d (d n)) n) (/= (d n) n))
          (pushnew (d n) a)
          (pushnew n     a))))
    (sum a)))

<hr />
<span class="comment-delimiter">;;; </span><span class="comment">Problem 22. Name Scores
</span><span class="comment-delimiter">;; </span><span class="comment">Using names.txt, a 46K text file containing over five-thousand
</span><span class="comment-delimiter">;; </span><span class="comment">first names, begin by sorting it into alphabetical order.
</span><span class="comment-delimiter">;; </span><span class="comment">Then working out the alphabetical value for each name, multiply
</span><span class="comment-delimiter">;; </span><span class="comment">this value by its alphabetical position in the list to obtain
</span><span class="comment-delimiter">;; </span><span class="comment">a name score.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">For example, when the list is sorted into alphabetical order,
</span><span class="comment-delimiter">;; </span><span class="comment">COLIN, which is worth 3 + 15 + 12 + 9 + 14 = 53, is the 938th
</span><span class="comment-delimiter">;; </span><span class="comment">name in the list. So COLIN would obtain a score of 938 * 53 = 49714.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">What is the total of all the name scores in the file?
</span><span class="comment-delimiter">;;</span><span class="comment">
</span>
(<span class="keyword">defun</span> <span class="function-name">read-file</span> (path <span class="type">&amp;optional</span> (eof-error-p t) eof-value)
  <span class="doc">"Read file at PATH. "</span>
  (<span class="keyword">with-open-file</span> (stream path)
    (read stream eof-error-p eof-value)))

(<span class="keyword">defun</span> <span class="function-name">problem22</span> ()
  (<span class="keyword">let</span> ((scores (mapcar (<span class="keyword">lambda</span> (name)
                          (<span class="keyword">loop</span> for c across name
                                sum (- (char-code c) (char-code #\A) -1)))
                        (sort (read-file <span class="string">"./dat/0022_names.sexp"</span>) #'string&lt;))))
    (<span class="keyword">loop</span> for i from 1
          for score in scores
          sum (* i score))))

<hr />
<span class="comment-delimiter">;;; </span><span class="comment">Problem 23. Non-Abundant Sums
</span><span class="comment-delimiter">;; </span><span class="comment">A perfect number is a number for which the sum of its proper divisors
</span><span class="comment-delimiter">;; </span><span class="comment">is exactly equal to the number. For example, the sum of the proper divisors
</span><span class="comment-delimiter">;; </span><span class="comment">of 28 would be 1 + 2 + 4 + 7 + 14 = 28, which means that 28 is a
</span><span class="comment-delimiter">;; </span><span class="comment">perfect number.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">A number n is called deficient if the sum of its proper divisors is
</span><span class="comment-delimiter">;; </span><span class="comment">less than n and it is called abundant if this sum exceeds n.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">As 12 is the smallest abundant number, 1 + 2 + 3 + 4 + 6 = 16, the
</span><span class="comment-delimiter">;; </span><span class="comment">smallest number that can be written as the sum of two abundant numbers
</span><span class="comment-delimiter">;; </span><span class="comment">is 24. By mathematical analysis, it can be shown that all integers
</span><span class="comment-delimiter">;; </span><span class="comment">greater than 28123 can be written as the sum of two abundant numbers.
</span><span class="comment-delimiter">;; </span><span class="comment">However, this upper limit cannot be reduced any further by analysis
</span><span class="comment-delimiter">;; </span><span class="comment">even though it is known that the greatest number that cannot be expressed
</span><span class="comment-delimiter">;; </span><span class="comment">as the sum of two abundant numbers is less than this limit.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">Find the sum of all the positive integers which cannot be written
</span><span class="comment-delimiter">;; </span><span class="comment">as the sum of two abundant numbers.
</span>
(defun-cached (abundant-number-p <span class="builtin">:fallback</span> <span class="builtin">:null</span>) (n)
  <span class="string">"Test if N is abundant number. "</span>
  (&lt; n (- (sum (divisors n)) n)))

(<span class="keyword">defun</span> <span class="function-name">sum-of-abundant-number-p</span> (n)
  <span class="doc">"Test if N can be splited as two abundant number. "</span>
  (<span class="keyword">loop</span> for i from (1- n) downto 1
        for j = (- n i)
        while (&lt;= j i)
        if (and (abundant-number-p i)
                (abundant-number-p j))
          return t
        finally (<span class="keyword">return</span> nil)))

(<span class="keyword">defun</span> <span class="function-name">problem23</span> ()
  <span class="doc">"Return the sum of all the positive integers which cannot be
written as two abundant numbers. "</span>
  (<span class="keyword">let</span> ((cache (make-array (1+ 28123))))
    (<span class="keyword">loop</span> for i from 12 upto 28123
          do (setf (aref cache i) (abundant-number-p i)))
    (<span class="keyword">loop</span> for n from 1 upto 28123
          if (not (sum-of-abundant-number-p n))
            sum n)))

<hr />
<span class="comment-delimiter">;;; </span><span class="comment">Problem 24. Lexicographic Permutations
</span><span class="comment-delimiter">;; </span><span class="comment">A permutation is an ordered arrangement of objects.
</span><span class="comment-delimiter">;; </span><span class="comment">For example, 3124 is one possible permutation of the digits
</span><span class="comment-delimiter">;; </span><span class="comment">1, 2, 3 and 4. If all of the permutations are listed numerically
</span><span class="comment-delimiter">;; </span><span class="comment">or alphabetically, we call it lexicographic order.
</span><span class="comment-delimiter">;; </span><span class="comment">The lexicographic permutations of 0, 1 and 2 are:
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;;   </span><span class="comment">012 021 102 120 201 210
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">What is the millionth lexicographic permutation of the digits
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;;   </span><span class="comment">0, 1, 2, 3, 4, 5, 6, 7, 8 and 9
</span><span class="comment-delimiter">;;</span><span class="comment">
</span>
<span class="comment-delimiter">;; </span><span class="comment">The idea is Zipper data structure:
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;;     </span><span class="comment">unfold  |   fold
</span><span class="comment-delimiter">;;               </span><span class="comment">(1 2 3 4)
</span><span class="comment-delimiter">;;         </span><span class="comment">(1)   (2 3 4)    ; move
</span><span class="comment-delimiter">;;       </span><span class="comment">(2 1)   (3 4)      ; move
</span><span class="comment-delimiter">;;     </span><span class="comment">(4 2 1)   (4)        ; move
</span><span class="comment-delimiter">;;             </span><span class="comment">^
</span><span class="comment-delimiter">;;      </span><span class="comment">current position
</span><span class="comment-delimiter">;;</span><span class="comment">
</span>
(<span class="keyword">defun</span> <span class="function-name">insert-between-list</span> (list elem)
  <span class="doc">"Insert ELEM in LIST and return a new list of all the inserted new list.

Example:

    (insert-between-list '(1) 2)
    ;; =&gt; ((1 2) (2 1))
"</span>
  (<span class="keyword">loop</span> with folded = ()
        with unfold = list
        with collected = ()
        while unfold
        do (push (append (reverse folded) (list elem) unfold) collected)
        do (push (pop unfold) folded)
        finally (<span class="keyword">progn</span>
                  (push (reverse (cons elem folded)) collected)
                  (<span class="keyword">return</span> collected))))

<span class="comment-delimiter">;; </span><span class="comment">Algorithm:
</span><span class="comment-delimiter">;; </span><span class="comment">permutation-list(()) = '(())
</span><span class="comment-delimiter">;; </span><span class="comment">permutation-list(elements = (first . rest))
</span><span class="comment-delimiter">;;  </span><span class="comment">= insert-between(one of permutation-list(rest), first)
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">for example:
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">(trace permutation-list)
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">0: (EULER::PERMUTATION-LIST (0 1 2))
</span><span class="comment-delimiter">;;   </span><span class="comment">1: (EULER::PERMUTATION-LIST (1 2))
</span><span class="comment-delimiter">;;     </span><span class="comment">2: (EULER::PERMUTATION-LIST (2))
</span><span class="comment-delimiter">;;       </span><span class="comment">3: (EULER::PERMUTATION-LIST NIL)
</span><span class="comment-delimiter">;;       </span><span class="comment">3: permutation-list returned (nil)
</span><span class="comment-delimiter">;;     </span><span class="comment">2: permutation-list returned ((2))
</span><span class="comment-delimiter">;;   </span><span class="comment">1: permutation-list returned ((2 1) (1 2))
</span><span class="comment-delimiter">;; </span><span class="comment">0: permutation-list returned ((2 1 0) (2 0 1) (0 2 1) (1 2 0) (1 0 2) (0 1 2))
</span><span class="comment-delimiter">;;</span><span class="comment">
</span>
(<span class="keyword">defun</span> <span class="function-name">permutation-list</span> (elements)
  <span class="doc">"Return a list of permutated of ELEMENTS.

Example:

    (permutation-list (range-list 0 2))
    ;; =&gt; ((2 1 0) (2 0 1) (0 2 1) (1 2 0) (1 0 2) (0 1 2))

"</span>
  (<span class="keyword">if</span> (endp elements) '(())
      (apply #'append
             (mapcar (rcurry #'insert-between-list (car elements))
                     (permutation-list (cdr elements))))))

(<span class="keyword">defun</span> <span class="function-name">list&lt;</span> (list1 list2)
  <span class="doc">"Test if two LIST1 and LIST2 are in lexicographic order. "</span>
  (<span class="keyword">if</span> (endp list1) t
      (<span class="keyword">let</span> ((e1 (car list1))
            (e2 (car list2)))
        (<span class="keyword">cond</span> ((= e1 e2) (list&lt; (cdr list1) (cdr list2)))
              ((&lt; e1 e2) t)
              (t         nil)))))

(<span class="keyword">defun</span> <span class="function-name">lexicographic-permutation-list</span> (elements)
  <span class="doc">"Return a lexicographic permutation list of ELEMENTS. "</span>
  (sort (permutation-list elements) #'list&lt;))

(<span class="keyword">defun</span> <span class="function-name">problem24</span> ()
  <span class="doc">"Return million-th lexicographic permutation. "</span>
  (nth (1- +million+) (lexicographic-permutation-list (range-list 0 9))))

<hr />
<span class="comment-delimiter">;;; </span><span class="comment">Problem 25. 1000-digit Fibonacci Number
</span><span class="comment-delimiter">;; </span><span class="comment">What is the index of the first term in the Fibonacci sequence
</span><span class="comment-delimiter">;; </span><span class="comment">to contain 1000 digits.
</span>
(<span class="keyword">defun</span> <span class="function-name">count-digits</span> (n <span class="type">&amp;optional</span> (base 10))
  <span class="doc">"This is equal to (length (digits n base)). "</span>
  (1+ (truncate (log n base))))

(<span class="keyword">defun</span> <span class="function-name">problem25</span> (<span class="type">&amp;optional</span> (digits 1000))
  <span class="doc">"Return the first Fibonacci number contain DIGITS. "</span>
  (<span class="keyword">loop</span> with f1 = 1
        with f2 = 1
        for i from 2
        if (= (count-digits f2) digits)
          return i
        do (shiftf f1 f2 (+ f1 f2))))

<hr />
<span class="comment-delimiter">;;; </span><span class="comment">Problem 26. Reciprocal Cycles
</span><span class="comment-delimiter">;; </span><span class="comment">A unit fraction contains 1 in the number. The decimal representation
</span><span class="comment-delimiter">;; </span><span class="comment">of the unit fractions with denominators 2 to 10 are given:
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;;   </span><span class="comment">1/2 = 0.5
</span><span class="comment-delimiter">;;   </span><span class="comment">1/3 = 0.(3)
</span><span class="comment-delimiter">;;   </span><span class="comment">1/4 = 0.25
</span><span class="comment-delimiter">;;   </span><span class="comment">1/5 = 0.2
</span><span class="comment-delimiter">;;   </span><span class="comment">1/6 = 0.1(6)
</span><span class="comment-delimiter">;;   </span><span class="comment">1/7 = 0.(142857)
</span><span class="comment-delimiter">;;   </span><span class="comment">1/8 = 0.125
</span><span class="comment-delimiter">;;   </span><span class="comment">1/9 = 0.(1)
</span><span class="comment-delimiter">;;  </span><span class="comment">1/10 = 0.1
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">Where 0.1(6) means 0.166666..., and has a 1-digit recurring cycle.
</span><span class="comment-delimiter">;; </span><span class="comment">It can be seen that 1/7 has a 6-digit recurring cycle.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">Find the value of d &lt; 1000 for which 1/d contains the longest
</span><span class="comment-delimiter">;; </span><span class="comment">recurring cycle in its decimal fraction part.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span>
(<span class="keyword">defun</span> <span class="function-name">proper-fraction</span> (rational)
  <span class="doc">"Return values are proper fraction of RATIONAL, mixed number. "</span>
  (<span class="keyword">let</span> ((n (numerator   rational))
        (d (denominator rational)))
    (values (/ (mod n d) d) (* d (floor (/ n d))))))

<span class="comment-delimiter">;; </span><span class="comment">if only contain 2 or 5, the RATIONAL is not infinite
</span><span class="comment-delimiter">;; </span><span class="comment">loop decimal number
</span>
(<span class="keyword">defun</span> <span class="function-name">infinite-loop-decimal-number-p</span> (rational)
  <span class="doc">"Test if RATIONAL is infinite loop decimal number. "</span>
  (<span class="keyword">declare</span> (type rational rational))
  (and (find-if (<span class="keyword">lambda</span> (fact-order)
                  (<span class="keyword">destructuring-bind</span> (fact . order) fact-order
                    (<span class="keyword">declare</span> (ignore order))
                    (and (/= fact 2) (/= fact 5))))
                (factors (denominator rational)))
       t))

<span class="comment-delimiter">;; </span><span class="comment">If remainder of long division starts to repeat,
</span><span class="comment-delimiter">;; </span><span class="comment">the dicimal would start to repeat.
</span>
(<span class="keyword">defun</span> <span class="function-name">decimal-recurring-cycle</span> (rational)
  <span class="doc">"Return the decimal recurring cycle list of RATIONAL. "</span>
  (<span class="keyword">declare</span> (type rational rational))
  (<span class="keyword">when</span> (infinite-loop-decimal-number-p rational)
    (<span class="keyword">let*</span> ((rational (proper-fraction rational))
           (n (numerator   rational))
           (d (denominator rational)))
      (<span class="keyword">loop</span> for num = (mod n d) then (mod (* num 10) d)
            for idx from 0
            for digit     = (floor (/ (* num 10) d))
            for remainder = (mod num d)

            <span class="comment-delimiter">;; </span><span class="comment">remainder is ((nth-division-remainder . nth) ...)
</span>            <span class="comment-delimiter">;; </span><span class="comment">which is used to test if repeating
</span>            for repeat    = (find remainder remainders <span class="builtin">:key</span> #'car)
            while (not repeat)
            collect digit into cycle
            collect (cons remainder idx) into remainders
            finally (<span class="keyword">return</span> (values (nthcdr (cdr repeat) cycle)
                                    (subseq cycle 0 (cdr repeat))))))))

(<span class="keyword">defun</span> <span class="function-name">problem26</span> (<span class="type">&amp;optional</span> (max 1000))
  <span class="doc">"Return the longest decimal part. "</span>
  (<span class="keyword">loop</span> with dmax = 0
        with lmax = 0
        for d from 1 below max
        for l = (length (decimal-recurring-cycle (/ 1 d)))
        if (&gt; l lmax)
          do (setf lmax l
                   dmax d)
        finally (<span class="keyword">return</span> dmax)))

<hr />
<span class="comment-delimiter">;;; </span><span class="comment">Problem 27. Quadratic Primes
</span><span class="comment-delimiter">;; </span><span class="comment">Euler discovered the remarkable quadratic formula:
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;;     </span><span class="comment">n^2 + n + 41
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">It turns out that the formula will produce 40 primes for the
</span><span class="comment-delimiter">;; </span><span class="comment">consecutive integer values 0 &lt;= n &lt;= 39. However, when n = 40,
</span><span class="comment-delimiter">;; </span><span class="comment">40^2 + 40 + 41 = 40 * (40 + 1) + 41 is divisible by 41, and
</span><span class="comment-delimiter">;; </span><span class="comment">certainly when n = 41, 41^2 + 41 + 41 is clearly divisible by 41.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">The incredible formula n^2 - 79 * n + 1601 was discovered,
</span><span class="comment-delimiter">;; </span><span class="comment">which produces 80 primes for the consecutive values 0 &lt;= n &lt;= 79.
</span><span class="comment-delimiter">;; </span><span class="comment">The product of the coefficients, -79 and 1601, is -126479.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">Considering quadratics of the form:
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;;     </span><span class="comment">n^2 + a * n + b, where |a| &lt; 1000 and |b| &lt;= 1000
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;;     </span><span class="comment">where |n| is the modulus/absolute value of n,
</span><span class="comment-delimiter">;;     </span><span class="comment">e.g. |11| = 11 and |-4| = 4
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">Find the product of the coefficients, a and b, for the quadratic
</span><span class="comment-delimiter">;; </span><span class="comment">expression that produces the maximum number of primes for
</span><span class="comment-delimiter">;; </span><span class="comment">consecutive values of n, starting with n = 0.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span>
(<span class="keyword">defun</span> <span class="function-name">quadratic-formula-prime-ability-count</span> (a b)
  <span class="doc">"Count the max n of n^2 + a * n + b that make it as a prime.

Example:

    (quadratic-formula-prime-ability-count   1   41) ; =&gt; 40
    (quadratic-formula-prime-ability-count -79 1601) ; =&gt; 80
"</span>
  (<span class="keyword">loop</span> for n from 0
        for primep = (primep (abs (+ (square n) (* a n) b)))
        while primep
        count primep))

(<span class="keyword">defun</span> <span class="function-name">problem27</span> (<span class="type">&amp;optional</span> (amax (1- 1000)) (bmax 1000))
  <span class="doc">"Find the product of the coefficients of the max
quadratic formula prime count. "</span>
  (<span class="keyword">loop</span> with max-a = 0
        with max-b = 0
        with max   = 0
        for a from (- amax) upto amax
        do (<span class="keyword">loop</span> for b from (- bmax) upto bmax
                 for cnt = (quadratic-formula-prime-ability-count a b)
                 if (&gt; cnt max)
                   do (setf max   cnt
                            max-a a
                            max-b b))
        finally (<span class="keyword">return</span> (* max-a max-b))))

<hr />
<span class="comment-delimiter">;;; </span><span class="comment">Problem 28. Number Spiral Diagonals
</span><span class="comment-delimiter">;; </span><span class="comment">Starting with the number 1 and moving to the right in a clockwise
</span><span class="comment-delimiter">;; </span><span class="comment">direction a 5 by 5 spiral is formed as follows:
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;;    </span><span class="comment">21 22 23 24 25
</span><span class="comment-delimiter">;;    </span><span class="comment">20  7  8  9 10
</span><span class="comment-delimiter">;;    </span><span class="comment">19  6  1  2 11
</span><span class="comment-delimiter">;;    </span><span class="comment">18  5  4  3 12
</span><span class="comment-delimiter">;;    </span><span class="comment">17 16 15 14 13
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">It can be verified that the sum of the numbers on the diagonals
</span><span class="comment-delimiter">;; </span><span class="comment">is 101.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">What is the sum of the numbers on the diagonals in a 1001 by 1001
</span><span class="comment-delimiter">;; </span><span class="comment">spiral formed in the same way?
</span><span class="comment-delimiter">;;</span><span class="comment">
</span>
<span class="comment-delimiter">;; </span><span class="comment">width of nth layer: 1, 3, 5, ...
</span><span class="comment-delimiter">;; </span><span class="comment">start of nth layer: end of n-1th layer + width of nth layer + 1
</span>
(<span class="keyword">defun</span> <span class="function-name">problem28</span> (<span class="type">&amp;optional</span> (size 1001))
  <span class="doc">"Return the sum of the diagonals. "</span>
  (<span class="keyword">loop</span> with sum = 1
        with num = 1
        for layer from 2
        for width from 3 upto size by 2
        <span class="comment-delimiter">;; </span><span class="comment">calculate start of nth layer, sum it
</span>        do (incf sum (incf num (1+ (- width 2))))
        do (<span class="keyword">dotimes</span> (i 3) (incf sum (incf num (1- width))))
        finally (<span class="keyword">return</span> sum)))

<hr />
<span class="comment-delimiter">;;; </span><span class="comment">Problem 29. Distinct Powers
</span><span class="comment-delimiter">;; </span><span class="comment">Consider all integer combinations of a^b for 2 &lt;= a &lt;= 5 and 2 &lt;= b &lt;= 5:
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;;    </span><span class="comment">2^2 = 4,     2^3 = 8,    2^4 = 16,    2^5 = 32
</span><span class="comment-delimiter">;;    </span><span class="comment">3^2 = 9,     3^3 = 27,   3^4 = 81,    3^5 = 243
</span><span class="comment-delimiter">;;    </span><span class="comment">4^2 = 16,    4^3 = 64,   4^4 = 256,   4^5 = 1024
</span><span class="comment-delimiter">;;    </span><span class="comment">5^2 = 25,    5^3 = 125,  5^4 = 625,   5^5 = 3125
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">If they are then placed in numerical order, with any repeats
</span><span class="comment-delimiter">;; </span><span class="comment">removed, we get the following sequence of 15 distinct terms:
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;;    </span><span class="comment">4, 8, 9, 16, 25, 27, 32, 64, 81, 125, 243, 256, 625, 1024, 3125
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">How many distinct terms are in the sequence generated by a^b for
</span><span class="comment-delimiter">;; </span><span class="comment">2 &lt;= a &lt;= 100 and 2 &lt;= b &lt;= 100?
</span><span class="comment-delimiter">;;</span><span class="comment">
</span>
(<span class="keyword">defun</span> <span class="function-name">problem29</span> (<span class="type">&amp;optional</span> (amax 100) (bmax 100))
  <span class="doc">"Return terms of a^b. "</span>
  (<span class="keyword">loop</span> for a from 2 upto amax
        collect (<span class="keyword">loop</span> for b from 2 upto bmax
                      collect (expt a b))
          into terms
        finally (<span class="keyword">return</span> (length (reduce #'union terms)))))

<hr />
<span class="comment-delimiter">;;; </span><span class="comment">Problem 30. Digit Fifth Powers
</span><span class="comment-delimiter">;; </span><span class="comment">Surprisingly there are only three numbers that can be written as the sum
</span><span class="comment-delimiter">;; </span><span class="comment">of fourth powers of their digits:
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;;    </span><span class="comment">1634 = 1^4 + 6^4 + 3^4 + 4^4
</span><span class="comment-delimiter">;;    </span><span class="comment">8208 = 8^4 + 2^4 + 0^4 + 8^4
</span><span class="comment-delimiter">;;    </span><span class="comment">9474 = 9^4 + 4^4 + 7^4 + 4^4
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">As 1 = 1^4 is not a sum it is not included.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">The sum of these numbers is 1634 + 8208 + 9474 = 19316.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">Find the sum of all the numbers that can be written as the
</span><span class="comment-delimiter">;; </span><span class="comment">sum of fifth powers of their digits.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span>
<span class="comment-delimiter">;; </span><span class="comment">Notice that 9^5 * 6 &lt; 111111 gives the upper limit of the
</span><span class="comment-delimiter">;; </span><span class="comment">number that could be written as the sum of powers of digits
</span>
(<span class="keyword">defun</span> <span class="function-name">solve-count-digits-n*9^k=n</span> (k)
  <span class="doc">"Solve the equation of: (count-digits 9^k * n) &lt;= n. "</span>
  (<span class="keyword">loop</span> with 9^k = (expt 9 k)
        for sum from (+ 9^k 9^k) by 9^k
        for n from 3
        if (&lt;= (count-digits sum) n)
          return n))

(<span class="keyword">defun</span> <span class="function-name">problem30</span> (<span class="type">&amp;optional</span> (exp 5))
  <span class="doc">"Return the sum of numbers that can be written as sum of EXP powers of its digits. "</span>
  (<span class="keyword">loop</span> for n from 2 below (* (solve-count-digits-n*9^k=n exp) (expt 9 exp))
        if (= n (sum (mapcar (<span class="keyword">lambda</span> (d) (expt d exp)) (p-digits n))))
          sum n))

<hr />
<span class="comment-delimiter">;;; </span><span class="comment">Problem 31. Coin Sums
</span><span class="comment-delimiter">;; </span><span class="comment">In the United Kingdom the currency is made up of pound (&#163;) and pence (p).
</span><span class="comment-delimiter">;; </span><span class="comment">There are eight coins in general circulation:
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;;    </span><span class="comment">1p, 2p, 5p, 10p, 20p, 50p, &#163;1 (100p), and &#163;2 (200p)
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">It is possible to make &#163;2 in the following way:
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;;    </span><span class="comment">1 * &#163;1  + 1 * 50p + 2 * 20p + 1 * 5p + 1 * 2p + 3 * 1p
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">How many different ways can &#163;2 be made using any number of coins?
</span><span class="comment-delimiter">;;</span><span class="comment">
</span>
(ql:quickload <span class="builtin">:sycamore</span>)

<span class="comment-delimiter">;; </span><span class="comment">The tree is used for faster insert
</span>
(<span class="keyword">defun</span> <span class="function-name">coin-split</span> (total <span class="type">&amp;optional</span> (coins (list 1 2 5 10 20 50 100 200)))
  <span class="doc">"Count how many ways to split TOTAL coin with COINS. "</span>
  (<span class="keyword">let</span> ((coins (sort coins #'&lt;))
        (len (length coins)))
    (<span class="keyword">flet</span> ((compare (pat1 pat2)
             (<span class="keyword">loop</span> for id1 from 0 below len
                   for id2 from 0 below len
                   if (&lt; (aref pat1 id1) (aref pat2 id2))
                     return -1
                   if (&gt; (aref pat1 id2) (aref pat2 id2))
                     return  1
                   finally (<span class="keyword">return</span> 0)))
           (inc-pattern (pat idx)
             (<span class="keyword">let</span> ((pat (<span class="keyword">if</span> (arrayp pat)
                            (make-array len <span class="builtin">:initial-contents</span> pat)
                            (make-array len <span class="builtin">:initial-element</span>  pat))))
               (incf (aref pat idx))
               pat)))
      (<span class="keyword">let</span> ((cache (make-array total)))
        (<span class="keyword">loop</span> for tol from 1 upto total do
          (<span class="keyword">loop</span> with patterns = (sycamore:tree-set #'compare)
                for idx from 0
                for coin in coins
                if (= coin tol)
                  do (setf patterns (sycamore:tree-set-insert patterns (inc-pattern 0 idx)))
                if (&lt; coin tol)
                  do (sycamore:map-tree-set
                      nil
                      (<span class="keyword">lambda</span> (pat)
                        (setf patterns (sycamore:tree-set-insert patterns (inc-pattern pat idx))))
                      (aref cache (1- (- tol coin))))
                finally (setf (aref cache (1- tol)) patterns))
              do (print (cons tol (sycamore:tree-set-count (aref cache (1- tol)))))
              finally (<span class="keyword">return</span> (aref cache (1- total))))))))

(<span class="keyword">defun</span> <span class="function-name">problem31</span> (<span class="type">&amp;optional</span> (total 200))
  <span class="doc">"Return how many different ways can 200 be splited. "</span>
  (length (coin-split total)))

<hr />
<span class="comment-delimiter">;;; </span><span class="comment">Problem 32. Pandigital Products
</span><span class="comment-delimiter">;; </span><span class="comment">We shall say that an n-digit number is pandigital if it makes use of all
</span><span class="comment-delimiter">;; </span><span class="comment">the digits 1 to n exactly once; for example, the 5-digit number, 15234
</span><span class="comment-delimiter">;; </span><span class="comment">is 1 through 5 pandigital.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">The product 7254 is unusual, as the identity, 39 * 186 = 7254, containing
</span><span class="comment-delimiter">;; </span><span class="comment">multiplicand, multiplier, and product is 1 through 9 pandigital.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">Find the sum of all products whose multiplicand / multiplier / product
</span><span class="comment-delimiter">;; </span><span class="comment">identity can be written as a 1 through 9 pandigital.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">HINT: Some products can be obtained in more than one way so be sure to only
</span><span class="comment-delimiter">;; </span><span class="comment">include it once in your sum.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span>
(<span class="keyword">defun</span> <span class="function-name">split-list-map</span> (func list n)
  <span class="doc">"Split LIST into N parts (not empty) and apply FUNC on splited.

Example:

    (split-list-map func '(1 2 3) 2)
    ;; =&gt; (func '(1) '(2 3))
    ;; =&gt; (func '(1 2) '(3))
"</span>
  (<span class="keyword">declare</span> (type function func)
           (type list list)
           (type (integer 1) n))
  (<span class="keyword">labels</span> ((iter (list n prev)
             (<span class="keyword">if</span> (= n 1)
                 (apply func (reverse (cons list prev)))
                 (<span class="keyword">loop</span> for (elem . rest) on list
                       collect elem into split
                       while (not (endp rest))
                       do (iter rest (1- n) (cons split prev))))))
    (iter list n ())))

(<span class="keyword">defun</span> <span class="function-name">problem32</span> (<span class="type">&amp;optional</span> (n 9))
  <span class="doc">"Return the sum of all products. "</span>
  (<span class="keyword">let</span> ((products ()))
    (<span class="keyword">dolist</span> (digits (permutation-list (range-list 1 n)) (sum products))
      (split-list-map (<span class="keyword">lambda</span> (a b prod)
                        (<span class="keyword">let</span> ((prod (int&lt;-p-digits prod)))
                          (<span class="keyword">when</span> (= (* (int&lt;-p-digits a) (int&lt;-p-digits b)) prod)
                            (pushnew prod products))))
                      digits
                      3))))

<hr />
<span class="comment-delimiter">;;; </span><span class="comment">Problem 33. Digit Cancelling Fractions
</span><span class="comment-delimiter">;; </span><span class="comment">The fraction 49/98 is a curious fraction, as an inexperienced mathematician
</span><span class="comment-delimiter">;; </span><span class="comment">in attempting to simplify it may incorrectly believe that 49/98 = 4/8,
</span><span class="comment-delimiter">;; </span><span class="comment">which is correct, is obtained by cancelling the 9s.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">We shall consider fractions like, 30/50 = 3/5, to be trivial examples.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">These are exactly four non-trivial examples of this type of fraction,
</span><span class="comment-delimiter">;; </span><span class="comment">less than one in value, and containing two digits in the numerator and
</span><span class="comment-delimiter">;; </span><span class="comment">denominator.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">If the product of these four fractions is given in its lowest common
</span><span class="comment-delimiter">;; </span><span class="comment">terms, find the value of the denominator.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span>
(<span class="keyword">defun</span> <span class="function-name">list-xor</span> (list1 list2 <span class="type">&amp;key</span> (test #'eql))
  <span class="doc">"Return values are XORed LIST1 and LIST2 by TEST.

Example:

    (list-xor '(1 2 3) '(2 3 4))
    ;; =&gt; (1), (4)
"</span>
  (<span class="keyword">flet</span> ((find* (list) (<span class="keyword">lambda</span> (elem) (find elem list <span class="builtin">:test</span> test))))
    (values (remove-if (find* list2) list1)
            (remove-if (find* list1) list2))))

(<span class="keyword">defun</span> <span class="function-name">problem33</span> ()
  <span class="doc">"Return the product of four fractions denominator. "</span>
  (<span class="keyword">let</span> ((fractions ()))
    (<span class="keyword">loop</span> for d from 99 downto 12
          for d-digits = (p-digits d)
          do (<span class="keyword">loop</span> for n from (1- d) downto 11
                   for n-digits = (p-digits n)
                   if (not (and (modp n 10) (modp d 10)))
                     do (<span class="keyword">multiple-value-bind</span> (nn dd) (list-xor n-digits d-digits)
                          (<span class="keyword">let</span> ((nn (int&lt;-p-digits nn))
                                (dd (int&lt;-p-digits dd)))
                            (<span class="keyword">when</span> (and (not (zerop dd))
                                       (/= d dd) (/= n nn)
                                       (= (/ nn dd) (/ n d)))
                              (pushnew (/ n d) fractions)))))
          finally (<span class="keyword">return</span> (prod fractions)))))

<hr />
<span class="comment-delimiter">;;; </span><span class="comment">Problem 34. Digit Factorials
</span><span class="comment-delimiter">;; </span><span class="comment">145 is a curious number, as 1! + 4! + 5! = 1 + 24 + 120 = 145.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">Find the sum of all numbers which are equal to the sum of the
</span><span class="comment-delimiter">;; </span><span class="comment">factorial of their digits.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">Note: As 1! = 1 and 2! = 2 are not sums they are not included.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span>
<span class="comment-delimiter">;; </span><span class="comment">Notice that 999999999 &gt; 7 * 9! = 2540160.
</span>
(<span class="keyword">defun</span> <span class="function-name">problem34</span> ()
  <span class="doc">"Return the sum of all numbers which are equal to the sum of
the factorial of their digits. "</span>
  (<span class="keyword">loop</span> for i from 10 upto (* 7 (factorial 9))
        if (= i (sum (mapcar #'factorial (p-digits i))))
          sum i))

<hr />
<span class="comment-delimiter">;;; </span><span class="comment">Problem 35. Circular Primes
</span><span class="comment-delimiter">;; </span><span class="comment">The number, 197, is called a circular prime because all rotations of
</span><span class="comment-delimiter">;; </span><span class="comment">the digits: 197, 971 and 719, are themselves prime.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">There are thirteen such primes below 100:
</span><span class="comment-delimiter">;; </span><span class="comment">2, 3, 5, 7, 11, 13, 17, 31, 37, 71, 73, 79, and 97
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">How many circular primes are there below one million?
</span><span class="comment-delimiter">;;</span><span class="comment">
</span>
(<span class="keyword">defun</span> <span class="function-name">rotate-list</span> (list <span class="type">&amp;optional</span> (n 1))
  <span class="doc">"Return rotated LIST by N. "</span>
  (append (subseq list n) (subseq list 0 n)))

(<span class="keyword">defun</span> <span class="function-name">circular-prime-p</span> (n)
  <span class="doc">"Test if N is circular prime.
Return values are boolean, rotated primes list. "</span>
  (<span class="keyword">loop</span> with n-digits = (p-digits n)
        for digits = n-digits then (rotate-list digits)
        for num = (int&lt;-p-digits digits)
        repeat (length n-digits)
        if (primep num)
          collect num into primes
        else
          return (values nil nil)
        finally (<span class="keyword">return</span> (values t primes))))

(<span class="keyword">defun</span> <span class="function-name">problem35</span> (<span class="type">&amp;optional</span> (max +million+))
  <span class="doc">"Count circular primes below MAX. "</span>
  (<span class="keyword">loop</span> with cache = (sycamore:tree-set (<span class="keyword">lambda</span> (a b)
                                          (<span class="keyword">cond</span> ((&lt; a b) -1)
                                                ((&gt; a b)  1)
                                                (t        0))))
        for n from 2 below max
        if (not (sycamore:tree-set-member-p cache n))
          do (<span class="keyword">multiple-value-bind</span> (- primes) (circular-prime-p n)
               (<span class="keyword">dolist</span> (prime primes)
                 (setf cache (sycamore:tree-set-insert cache prime))))
        finally (<span class="keyword">return</span> (sycamore:tree-set-count cache))))

<hr />
<span class="comment-delimiter">;;; </span><span class="comment">Problem 36. Double-base Palindromes
</span><span class="comment-delimiter">;; </span><span class="comment">The decimal number, 585 = #b1001001001 (binary), is palindromic
</span><span class="comment-delimiter">;; </span><span class="comment">in both bases.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">Find the sum of all numbers, less than one million, which are
</span><span class="comment-delimiter">;; </span><span class="comment">palindromic in base 10 and base 2.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span>
(<span class="keyword">defun</span> <span class="function-name">problem36</span> (<span class="type">&amp;optional</span> (max +million+) (base1 10) (base2 2))
  <span class="doc">"Return the dual palindromic in BASE1 and BASE2 below MAX. "</span>
  (<span class="keyword">loop</span> for n from 1 below max
        if (and (palindromep n base1)
                (palindromep n base2))
          sum n))

<hr />
<span class="comment-delimiter">;;; </span><span class="comment">Problem 37. Truncatable Primes
</span><span class="comment-delimiter">;; </span><span class="comment">The number 3797 has an interesting property. Being prime itself,
</span><span class="comment-delimiter">;; </span><span class="comment">it is possible to continuously remove digits from left to right,
</span><span class="comment-delimiter">;; </span><span class="comment">and remain prime at each stage: 3797, 797, 97, and 7. Similarly
</span><span class="comment-delimiter">;; </span><span class="comment">we can work from right to left: 3797, 379, 37, and 3.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">Find the sum of the only eleven primes that are both truncatable
</span><span class="comment-delimiter">;; </span><span class="comment">from left to right and right to left.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">Note: 2, 3, 5, and 7 are not considered to be truncatable primes.
</span>
(<span class="keyword">defun</span> <span class="function-name">truncatable-prime-p</span> (prime <span class="type">&amp;optional</span> (base 10))
  <span class="doc">"Test if PRIME is a truncatable prime.

Note 2, 3, 5, 7 are not considered to be truncatable primes. "</span>
  (and (&gt; prime 10)
       (<span class="keyword">loop</span> for digits on (p-digits prime base)
             if (not (primep (int&lt;-p-digits digits)))
               return nil
             finally (<span class="keyword">return</span> t))
       (<span class="keyword">loop</span> for p = (p-shift prime base) then (p-shift p base)
             until (zerop p)
             if (not (primep p))
               return nil
             finally (<span class="keyword">return</span> t))))

(<span class="keyword">defun</span> <span class="function-name">problem37</span> ()
  <span class="doc">"Find the sum of the only eleven primes that are truncatable primes. "</span>
  (<span class="keyword">loop</span> for p from 13
        if (truncatable-prime-p p)
          collect p into primes
        while (/= (length primes) 11)
        finally (<span class="keyword">return</span> (sum (print primes)))))

<hr />
<span class="comment-delimiter">;;; </span><span class="comment">Problem 38. Pandigital Multiples
</span><span class="comment-delimiter">;; </span><span class="comment">Take the number 192 and multiply it by each of 1, 2, and 3:
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;;    </span><span class="comment">192 * 1 = 192
</span><span class="comment-delimiter">;;    </span><span class="comment">192 * 2 = 384
</span><span class="comment-delimiter">;;    </span><span class="comment">192 * 3 = 576
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">By concatenating each product we get the 1 to 9 pandigital,
</span><span class="comment-delimiter">;; </span><span class="comment">192384576. We will call 192384576 the concatenated product
</span><span class="comment-delimiter">;; </span><span class="comment">of 192 and (1, 2, 3).
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">The same can be achieved by starting with 9 and multiplying
</span><span class="comment-delimiter">;; </span><span class="comment">by 1, 2, 3, 4, and 5, giving the pandigital, 918273645,
</span><span class="comment-delimiter">;; </span><span class="comment">which is the concatenated product of 9 and (1, 2, 3, 4, 5).
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">What is the largest 1 to 9 pandigital 9-digit number that
</span><span class="comment-delimiter">;; </span><span class="comment">can be formed as the concatenated product of an integer with
</span><span class="comment-delimiter">;; </span><span class="comment">(1, 2, ..., n) where n &gt; 1?
</span><span class="comment-delimiter">;;</span><span class="comment">
</span>
(<span class="keyword">defun</span> <span class="function-name">concatenate-product</span> (n multipliers <span class="type">&amp;optional</span> (base 10))
  <span class="doc">"Return the concatenating product of N and MULTIPLIERS.

Example:

    (concatenate-product 192 '(1 2 3))
    ;; =&gt; 192384576
"</span>
  (int&lt;-p-digits (apply #'concatenate 'list
                        (mapcar (<span class="keyword">lambda</span> (mul) (p-digits (* n mul) base)) multipliers))
                 base))

(<span class="keyword">defun</span> <span class="function-name">have-digits-p</span> (num digits <span class="type">&amp;key</span> (base 10) (strictp t) (uniquep t))
  <span class="doc">"Test if NUM has DIGITS and having them only. "</span>
  (<span class="keyword">let</span> ((cache (make-array base <span class="builtin">:initial-element</span> <span class="builtin">:not-used</span>)))
    (<span class="keyword">loop</span> for digit in digits do (setf (aref cache digit) nil))
    (<span class="keyword">loop</span> for digit in (p-digits num base)
          do (<span class="keyword">cond</span> ((eq (aref cache digit) <span class="builtin">:not-used</span>)
                    (<span class="keyword">when</span> strictp (<span class="keyword">return</span> nil)))
                   ((eq (aref cache digit) t)
                    (<span class="keyword">when</span> uniquep (<span class="keyword">return</span> nil)))
                   ((eq (aref cache digit) nil)
                    (setf (aref cache digit) t)))
          finally (<span class="keyword">return</span> (<span class="keyword">if</span> strictp
                              <span class="comment-delimiter">;; </span><span class="comment">check all digit is used
</span>                              (<span class="keyword">loop</span> for digit in digits
                                    if (not (aref cache digit))
                                      return nil
                                    finally (<span class="keyword">return</span> t))
                              t)))))

(<span class="keyword">defun</span> <span class="function-name">problem38</span> ()
  <span class="doc">"Return the largest pandigital 9-digit number that can be formed as the
product of an integer with (1, ..., n). "</span>
  (<span class="keyword">loop</span> with max = 0
        for n from 2 upto 9
        for ns = (range-list 1 n)
        do (<span class="keyword">loop</span> for i from 1
                 for prod = (concatenate-product i ns)
                 while (&lt;= prod 987654321)
                 if (and (&gt; prod max) (have-digits-p prod (range-list 1 9)))
                   do (setf max prod))
        finally (<span class="keyword">return</span> max)))

<hr />
<span class="comment-delimiter">;;; </span><span class="comment">Problem 39. Integer Right Triangles
</span><span class="comment-delimiter">;; </span><span class="comment">If p is the perimeter of a right angle triangle with integral length
</span><span class="comment-delimiter">;; </span><span class="comment">sides, {a, b, c}, there are exactly three solutions for p = 120.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;;   </span><span class="comment">{20, 48, 52}, {24, 45, 51}, {30, 40, 50}
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">For which value of p &lt;= 1000, is the number of solutions maximised?
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;;</span><span class="comment">
</span>
(<span class="keyword">defun</span> <span class="function-name">right-angle-triangle-p</span> (a b c)
  <span class="doc">"Test if A, B, C is a right angle triangle. "</span>
  (<span class="keyword">let*</span> ((max (max a b c))
         (min (min a b c))
         (mid (- (+ a b c) (+ min max))))
    (= (+ (square min) (square mid)) (square max))))

(<span class="keyword">defun</span> <span class="function-name">split-number-map</span> (func num n)
  <span class="doc">"Split NUM into N parts and apply FUNC on splited.

Example:

    (split-number-map func 3 2)
    ;; =&gt; (func 2 1)
    ;; =&gt; (func 1 2)
"</span>
  (<span class="keyword">declare</span> (type function func)
           (type number num)
           (type (integer 1) n))
  (<span class="keyword">labels</span> ((iter (num n prev)
             (<span class="keyword">if</span> (= n 1)
                 (apply func (reverse (cons num prev)))
                 (<span class="keyword">loop</span> with n-1 = (1- n)
                       for elem from (- num n-1) downto n-1
                       do (iter (- num elem) n-1 (cons elem prev))))))
    (iter num n ())))

(<span class="keyword">defun</span> <span class="function-name">count-right-angle-triangle-splittable</span> (p)
  <span class="doc">"Count for patterns {a, b, c} is right angle triangle, and a + b + c = p. "</span>
  (<span class="keyword">let</span> ((count 0))
    (split-number-map (<span class="keyword">lambda</span> (a b c)
                        (<span class="keyword">when</span> (and (&lt;= a b c) (right-angle-triangle-p a b c))
                          (incf count)))
                      p 3)
    count))

(<span class="keyword">defun</span> <span class="function-name">problem39</span> (<span class="type">&amp;optional</span> (max 1000))
  <span class="doc">"Return the max of count right angle triangle splittable p &lt; MAX. "</span>
  (<span class="keyword">loop</span> with max-cnt = 0
        with max-p   = 0
        for p from 12 below max
        for cnt = (count-right-angle-triangle-splittable p)
        if (&gt; cnt max-cnt)
          do (setf max-cnt cnt
                   max-p   p)
        finally (<span class="keyword">return</span> max-p)))

<hr />
<span class="comment-delimiter">;;; </span><span class="comment">Problem 40. Champernowne's Constant
</span><span class="comment-delimiter">;; </span><span class="comment">An irrational decimal fraction is created by concatenating the positive
</span><span class="comment-delimiter">;; </span><span class="comment">integers:
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;;    </span><span class="comment">0.123456789101112131415161718192021...
</span><span class="comment-delimiter">;;                 </span><span class="comment">^
</span><span class="comment-delimiter">;;                </span><span class="comment">12th
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">It can be seen that the 12th digit of the fractional part is 1.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">If d(n) represents the nth digit of the fractional part, find the value
</span><span class="comment-delimiter">;; </span><span class="comment">of the following expression.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;;    </span><span class="comment">d1 * d10 * d100 * d1000 * d10000 * d100000 * d1000000
</span><span class="comment-delimiter">;;</span><span class="comment">
</span>
(<span class="keyword">defun</span> <span class="function-name">problem40</span> (<span class="type">&amp;optional</span> (indexs (mapcar (curry #'expt 10) (range-list 1 6))))
  <span class="doc">"Return product of d(indexs). "</span>
  (<span class="keyword">loop</span> with idxs = (sort indexs #'&lt;)
        with nth = 1
        with prod = 1
        with current = (pop idxs)
        for num from 1
        do (<span class="keyword">loop</span> for di in (p-digits num)
                 if (= nth current)
                   do (setf prod    (* di prod)
                            current (pop idxs))
                 do (incf nth)
                 while current)
        while current
        finally (<span class="keyword">return</span> prod)))

<hr />
<span class="comment-delimiter">;;; </span><span class="comment">Problem 41. Pandigital Prime
</span><span class="comment-delimiter">;; </span><span class="comment">We shall say that an n-digit number is pandigitial if it makes use
</span><span class="comment-delimiter">;; </span><span class="comment">of all the digits 1 to n exactly once. For example, 2143 is a
</span><span class="comment-delimiter">;; </span><span class="comment">4-digit pandigital and is also prime.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">What is the largest n-digit pandigital prime that exists?
</span><span class="comment-delimiter">;;</span><span class="comment">
</span>
(<span class="keyword">defun</span> <span class="function-name">pandigitalp</span> (n <span class="type">&amp;optional</span> (base 10))
  <span class="doc">"Test if N is pandigital number. "</span>
  (<span class="keyword">let</span> ((digits (count-digits n base)))
    (<span class="keyword">when</span> (&lt; digits base)
      (have-digits-p n (range-list 1 digits)
                     <span class="builtin">:base</span> base <span class="builtin">:uniquep</span> t <span class="builtin">:strictp</span> t))))

(<span class="keyword">defun</span> <span class="function-name">problem41</span> ()
  <span class="doc">"Find the largest n-digit pandigital prime. "</span>
  (<span class="keyword">loop</span> for p from 2143 below 987654321 by 2
        if (and (pandigitalp p) (primep p))
          maximize (print p)))

(<span class="keyword">defun</span> <span class="function-name">problem41-other-way</span> ()
  <span class="doc">"Find the largest n-digit pandigital prime. "</span>
  (<span class="keyword">loop</span> for n from 9 downto 1
        for max = (<span class="keyword">loop</span> for p-digits in (permutation-list (range-list 1 n))
                        for p = (int&lt;-p-digits p-digits)
                        if (primep p)
                          maximize p)
        while (zerop max)
        finally (<span class="keyword">return</span> max)))

<hr />
<span class="comment-delimiter">;;; </span><span class="comment">Problem 42. Coded Triangle Numbers
</span><span class="comment-delimiter">;; </span><span class="comment">The nth term of the sequence of triangle numbers is given by
</span><span class="comment-delimiter">;; </span><span class="comment">t(n) = n * (n + 1) / 2; so the first ten triangle numbers are:
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;;    </span><span class="comment">1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">By converting each letter in a word to a number corresponding to its
</span><span class="comment-delimiter">;; </span><span class="comment">alphabetical position and adding these values we form a word value.
</span><span class="comment-delimiter">;; </span><span class="comment">For example, the word value for SKY is 19 + 11 + 25 = 55 = t(10).
</span><span class="comment-delimiter">;; </span><span class="comment">If the word value is a triangle number then we shall call the word
</span><span class="comment-delimiter">;; </span><span class="comment">a triangle word.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">Using words.txt containing nearly two-thousand common English
</span><span class="comment-delimiter">;; </span><span class="comment">words, how many are triangle words?
</span><span class="comment-delimiter">;;</span><span class="comment">
</span>
(<span class="keyword">defun</span> <span class="function-name">triangle-number</span> (n)
  <span class="doc">"Return triangle number n * (n + 1) / 2. "</span>
  (<span class="keyword">declare</span> (type integer n))
  (/ (* n (1+ n)) 2))

<span class="comment-delimiter">;; </span><span class="comment">solve equation:
</span><span class="comment-delimiter">;; </span><span class="comment">x ( x + 1 ) = 2 n
</span><span class="comment-delimiter">;; </span><span class="comment">=&gt; (sqrt(1 + 8 * n) - 1) / 2
</span>
(<span class="keyword">defun</span> <span class="function-name">triangle-number-p</span> (n)
  <span class="doc">"Test if N is triangle number. "</span>
  (<span class="keyword">let*</span> ((square (1+ (* 8 n)))
         (sqrt   (truncate (sqrt square))))
    (and (= square (square sqrt))
         (evenp (1- sqrt)))))

(<span class="keyword">defun</span> <span class="function-name">triangle-word-p</span> (word)
  <span class="doc">"Test if WORD is triangle word. "</span>
  (triangle-number-p
   (sum (map 'list (<span class="keyword">lambda</span> (c) (- (char-code c) (char-code #\A) -1)) word))))

(<span class="keyword">defun</span> <span class="function-name">problem42</span> ()
  <span class="doc">"Count triangle words. "</span>
  (<span class="keyword">loop</span> for word in (read-file <span class="string">"./dat/0042_words.sexp"</span>)
        count (triangle-word-p word)))

<hr />
<span class="comment-delimiter">;;; </span><span class="comment">Problem 43. Sub-string Divisibility
</span><span class="comment-delimiter">;; </span><span class="comment">The number, 1406357289, is a 0 to 9 pandigital number because it is
</span><span class="comment-delimiter">;; </span><span class="comment">made up of each of the digits 0 to 9 in some order, but it also has
</span><span class="comment-delimiter">;; </span><span class="comment">a rather interesting sub-string divisibility property.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">Let d(1) be the 1st digit, d(2) be the 2nd digit, and so on. In this way,
</span><span class="comment-delimiter">;; </span><span class="comment">we note the following:
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;;  </span><span class="comment">+ d2 * d3 * d4  = 406 is divisible by 2
</span><span class="comment-delimiter">;;  </span><span class="comment">+ d3 * d4 * d5  = 063 is divisible by 3
</span><span class="comment-delimiter">;;  </span><span class="comment">+ d4 * d5 * d6  = 635 is divisible by 5
</span><span class="comment-delimiter">;;  </span><span class="comment">+ d5 * d6 * d7  = 357 is divisible by 7
</span><span class="comment-delimiter">;;  </span><span class="comment">+ d6 * d7 * d8  = 572 is divisible by 11
</span><span class="comment-delimiter">;;  </span><span class="comment">+ d7 * d8 * d9  = 728 is divisible by 13
</span><span class="comment-delimiter">;;  </span><span class="comment">+ d8 * d9 * d10 = 289 is divisible by 17
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">Find the sum of all 0 to 9 pandigital numbers with this property.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span>
(<span class="keyword">defun</span> <span class="function-name">2+</span> (x)
  <span class="doc">"Return x + 2. "</span>
  (+ 2 x))

(<span class="keyword">defun</span> <span class="function-name">n-digit-prime-dividable-p</span> (n digits <span class="type">&amp;optional</span> (base 10))
  <span class="doc">"Test if subsequence of N size of DIGITS can be divided by nth prime. "</span>
  (<span class="keyword">let</span> ((i      0)
        (digits (<span class="keyword">if</span> (listp digits)
                    digits
                    (p-digits digits base))))
    (windowed-mapcar
     (<span class="keyword">lambda</span> (<span class="type">&amp;rest</span> n-di)
       (<span class="keyword">unless</span> (modp (int&lt;-p-digits n-di base) (nth-prime (incf i)))
         (<span class="keyword">return-from</span> n-digit-prime-dividable-p nil)))
     n digits)
    t))

(<span class="keyword">defun</span> <span class="function-name">problem43</span> ()
  <span class="doc">"Return the sum of all 0 to 9 pandigital numbers that can divide. "</span>
  (<span class="keyword">loop</span> for (d1 . digits) in (permutation-list (range-list 0 9))
        if (and (not (zerop d1)) <span class="comment">; 0********* should be ignored
</span>                (n-digit-prime-dividable-p 3 digits))
          sum (int&lt;-p-digits (cons d1 digits))))

<hr />
<span class="comment-delimiter">;;; </span><span class="comment">Problem 44. Pentagon Numbers
</span><span class="comment-delimiter">;; </span><span class="comment">Pentagonal numbers are generated by the formula, P(n) = n * (3 * n - 1) / 2.
</span><span class="comment-delimiter">;; </span><span class="comment">The first ten pentagonal numbers are:
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;;    </span><span class="comment">1, 5, 12, 22, 35, 51, 70, 92, 117, 145, ...
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">It can be seen that P(4) + P(7) = 22 + 70 = 92 = P(8).
</span><span class="comment-delimiter">;; </span><span class="comment">However, their differnce, 70 - 22 = 48, is not pentagonal.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">Find the pair of pentagonal numbers, P(j) and P(k), for which their
</span><span class="comment-delimiter">;; </span><span class="comment">sum and difference are pentagonal and D = |P(k) - P(j)| is minimised;
</span><span class="comment-delimiter">;; </span><span class="comment">what is the value of D?
</span><span class="comment-delimiter">;;</span><span class="comment">
</span>
(<span class="keyword">defun</span> <span class="function-name">pentagonal-number</span> (n)
  <span class="doc">"Return P(n) = n * (3 * n - 1) / 2. "</span>
  (/ (* n (- (* 3 n) 1)) 2))

<span class="comment-delimiter">;; </span><span class="comment">P(i) = n =&gt; i = (1 + sqrt(1 + 24 * k)) / 6
</span>
(<span class="keyword">defun</span> <span class="function-name">integer-square-p</span> (n)
  <span class="doc">"Test if N is m^2 where m is integer.
Return values are boolean, the sqrt of N (if t). "</span>
  (<span class="keyword">if</span> (and (integerp n) (&gt;= n 0))
      (<span class="keyword">let</span> ((sqrt (isqrt n)))
        (<span class="keyword">if</span> (= (square sqrt) n)
            (values t   sqrt)
            (values nil nil)))
      (values nil nil)))

(<span class="keyword">defun</span> <span class="function-name">pentagonal-number-p</span> (n)
  <span class="doc">"Test if N is pentagonal number. "</span>
  (<span class="keyword">multiple-value-bind</span> (sqrtp sqrt)
      (integer-square-p (1+ (* 24 n)))
    (<span class="keyword">if</span> (and sqrtp (modp (1+ sqrt) 6))
        (values t   (/ (1+ sqrt) 6))
        (values nil nil))))

<span class="comment-delimiter">;; </span><span class="comment">it is equal to searching:
</span><span class="comment-delimiter">;; </span><span class="comment">Pi, Pj, Pk, Pl as pentagonal numbers
</span>
(<span class="keyword">defun</span> <span class="function-name">problem44</span> ()
  <span class="doc">"Find the minimal D|P(k) - P(j)| is pentagonal. "</span>
  (<span class="keyword">let</span> ((cache (make-hash-table)))
    (<span class="keyword">flet</span> ((pentagonal (n)
             (or (gethash n cache)
                 (setf (gethash n cache) (pentagonal-number n)))))
      (<span class="keyword">loop</span> for sumi from 4
            for sum  = (pentagonal sumi)
            do (<span class="keyword">loop</span> for loweri from 1
                     for lower = (pentagonal loweri)
                     for upper = (- sum lower)
                     for diff  = (- upper lower)
                     while (&lt; lower upper)
                     if (and (pentagonal-number-p upper)
                             (pentagonal-number-p diff))
                       do (<span class="keyword">return-from</span> problem44 diff))))))

<hr />
<span class="comment-delimiter">;;; </span><span class="comment">Problem 45. Triangular, Pentagonal, and Hexagonal
</span><span class="comment-delimiter">;; </span><span class="comment">Triangle, pentagonal, and hexagonal numbers are generated by the
</span><span class="comment-delimiter">;; </span><span class="comment">following formulae:
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">Triangle   T(n) = n * (n + 1) / 2
</span><span class="comment-delimiter">;; </span><span class="comment">Pentagonal P(n) = n * (3 * n - 1) / 2
</span><span class="comment-delimiter">;; </span><span class="comment">Hexagonal  H(n) = n * (2 * n - 1)
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">It can be verified that T(285) = P(165) = H(143) = 40755
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">Find the next triangle number that is also pentagonal and hexagonal.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span>
(<span class="keyword">defun</span> <span class="function-name">hexagonal-number</span> (n)
  <span class="doc">"Return hexagonal number n * (2 * n - 1). "</span>
  (* n (1- (* 2 n))))

<span class="comment-delimiter">;; </span><span class="comment">(1 + sqrt(1 + 8 * n)) / 4
</span>
(<span class="keyword">defun</span> <span class="function-name">hexagonal-number-p</span> (n)
  <span class="doc">"Test if N is hexagonal number. "</span>
  (<span class="keyword">multiple-value-bind</span> (sqrtp sqrt)
      (integer-square-p (1+ (* 8 n)))
    (<span class="keyword">if</span> (and sqrtp (modp (1+ sqrt) 4))
        (values t   (/ (1+ sqrt) 4))
        (values nil nil))))

(<span class="keyword">defun</span> <span class="function-name">problem45</span> ()
  (<span class="keyword">loop</span> for i from (1+ 285)
        for ti = (triangle-number i)
        if (and (pentagonal-number-p ti)
                (hexagonal-number-p  ti))
          return ti))

<hr />
<span class="comment-delimiter">;;; </span><span class="comment">Problem 46. Goldbach's Other Conjecture
</span><span class="comment-delimiter">;; </span><span class="comment">It was proposed by Christian Goldbach that every odd composite number
</span><span class="comment-delimiter">;; </span><span class="comment">can be written as the sum of a prime and twice a square.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;;    </span><span class="comment">9 =  7 + 2 * 1^2
</span><span class="comment-delimiter">;;   </span><span class="comment">15 =  7 + 2 * 2^2
</span><span class="comment-delimiter">;;   </span><span class="comment">21 =  3 + 2 * 3^2
</span><span class="comment-delimiter">;;   </span><span class="comment">25 =  7 + 2 * 3^2
</span><span class="comment-delimiter">;;   </span><span class="comment">27 = 19 + 2 * 2^2
</span><span class="comment-delimiter">;;   </span><span class="comment">33 = 31 + 2 * 1^2
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">It turns out that the conjecture was false.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">What is the smallest odd composite that cannot be written as the sum
</span><span class="comment-delimiter">;; </span><span class="comment">of a prime and twice a square?
</span><span class="comment-delimiter">;;</span><span class="comment">
</span>
(<span class="keyword">defun</span> <span class="function-name">splitable-as-p-2*n^2-p</span> (n)
  <span class="doc">"Split N as p + 2 * n^2.
Return boolean, p, n. "</span>
  (<span class="keyword">loop</span> for i from 0
        for p = 1 then (nth-prime i)
        for 2n^2 = (- n p)
        while (&gt;= 2n^2 0)
        if (and (evenp 2n^2) (integer-square-p (/ 2n^2 2)))
          return (values t p (truncate (sqrt (/ 2n^2 2))))
        finally (<span class="keyword">return</span> (values nil nil nil))))

(<span class="keyword">defun</span> <span class="function-name">problem46</span> ()
  <span class="doc">"Return the smallest odd composite cannot split. "</span>
  (<span class="keyword">loop</span> for i from 1 by 2
        while (splitable-as-p-2*n^2-p i)
        finally (<span class="keyword">return</span> i)))

<hr />
<span class="comment-delimiter">;;; </span><span class="comment">Problem 47. Distinct Primes Factors
</span><span class="comment-delimiter">;; </span><span class="comment">The first two consecutive numbers to have two distinct prime factors are:
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;;     </span><span class="comment">14 = 2 * 7
</span><span class="comment-delimiter">;;     </span><span class="comment">15 = 3 * 5
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">The first three consecutive numbers to have three distinct prime factors
</span><span class="comment-delimiter">;; </span><span class="comment">are:
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;;     </span><span class="comment">644 = 2^2 * 7 * 23
</span><span class="comment-delimiter">;;     </span><span class="comment">645 = 3   * 5 * 43
</span><span class="comment-delimiter">;;     </span><span class="comment">646 = 2   * 17 * 19
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">Find the first four consecutive integers to have four distinct prime
</span><span class="comment-delimiter">;; </span><span class="comment">factors each. What is the first of these numbers?
</span><span class="comment-delimiter">;;</span><span class="comment">
</span>
(<span class="keyword">defun</span> <span class="function-name">problem47</span> (<span class="type">&amp;optional</span> (n 4))
  <span class="doc">"Find the first four consecutive integers. "</span>
  (<span class="keyword">loop</span> for i from (prod (mapcar #'nth-prime (range-list 1 n)))
        if (and-repeat (j n) (= (length (factors (+ i j))) n))
          return i))

<hr />
<span class="comment-delimiter">;;; </span><span class="comment">Problem 48. Self Powers
</span><span class="comment-delimiter">;; </span><span class="comment">The series, 1^1 + 2^2 + 3^3 + ... + 10^10 = 10405071317.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">Find the last ten digits of the series, 1^1 + 2^2 + 3^3 + ... + 1000^1000.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span>
(<span class="keyword">defun</span> <span class="function-name">self-power</span> (x)
  <span class="doc">"Return x^x. "</span>
  (expt x x))

(<span class="keyword">defun</span> <span class="function-name">problem48</span> ()
  <span class="doc">"Find the last ten digits of the series. "</span>
  (int&lt;-p-digits (last (p-digits (sum (mapcar #'self-power (range-list 1 1000)))) 10)))

<hr />
<span class="comment-delimiter">;;; </span><span class="comment">Problem 49. Prime Permutations
</span><span class="comment-delimiter">;; </span><span class="comment">The arithmetic sequence, 1487, 4817, 8147, in which each of the terms
</span><span class="comment-delimiter">;; </span><span class="comment">increases by 3330, is unusual in two ways: (i) each of the three terms
</span><span class="comment-delimiter">;; </span><span class="comment">are prime, and, (ii) each of the 4-digit numbers are permutations of
</span><span class="comment-delimiter">;; </span><span class="comment">one another.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">There are no arithmetic sequences made up of three 1-, 2-, or 3-digit
</span><span class="comment-delimiter">;; </span><span class="comment">primes, exhibiting this property, but there is one other 4-digit
</span><span class="comment-delimiter">;; </span><span class="comment">increasing sequence.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">What 12-digit number do you form by concatenating the three terms
</span><span class="comment-delimiter">;; </span><span class="comment">in this sequence?
</span><span class="comment-delimiter">;;</span><span class="comment">
</span>
(<span class="keyword">defun</span> <span class="function-name">n-pick-list</span> (set n)
  <span class="doc">"Return a list of element as N pick from set.

Example:

    (n-pick-list '(1 2 3) 2)
    ;; =&gt; ((1 2) (1 3) (2 3))
"</span>
  (<span class="keyword">declare</span> (type list set)
           (type (integer 0) n))
  (<span class="keyword">if</span> (= n 0) '(())
      (apply #'append
             (<span class="keyword">loop</span> for (elem . rest) on set
                   collect (mapcar (curry #'cons elem)
                                   (n-pick-list rest (1- n)))))))

(<span class="keyword">defun</span> <span class="function-name">n-digit-prime</span> (n <span class="type">&amp;optional</span> (base 10))
  <span class="doc">"Return prime number with N digits. "</span>
  (<span class="keyword">loop</span> for i from 1
        for p = (nth-prime i)
        if (&gt;= (count-digits p base) n)
          return (values p i)))

(<span class="keyword">defun</span> <span class="function-name">nearest-prime</span> (x <span class="type">&amp;optional</span> (sticky <span class="builtin">:left</span>))
  <span class="doc">"Find the nearest prime number to N. "</span>
  (<span class="keyword">declare</span> (type (real 0) x)
           (type (member <span class="builtin">:left</span> <span class="builtin">:nearest</span> <span class="builtin">:right</span>) sticky))
  (<span class="keyword">loop</span> for n from 1
        for pn   = (nth-prime n)
        for pn+1 = (nth-prime (1+ n))
        if (&lt;= pn x pn+1)
          return (<span class="keyword">ecase</span> sticky
                   (<span class="builtin">:left</span>
                    (values pn n))
                   (<span class="builtin">:nearest</span>
                    (<span class="keyword">if</span> (&lt; (- x pn) (- pn+1 x))
                        (values pn   n)
                        (values pn+1 (1+ n))))
                   (<span class="builtin">:right</span>
                    (values pn+1 (1+ n))))))

<span class="comment-delimiter">;; </span><span class="comment">Note: the expression of the problem is a little ambigiuous.
</span><span class="comment-delimiter">;; </span><span class="comment">Here's my version:
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">Definition: a sequence a(n, b) = 1487, 4817, 8147, ... = 3330 * n + b
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">Find the b that:
</span><span class="comment-delimiter">;; </span><span class="comment">1. make all a(n, b) is prime, if (a(n, b) is 4-digit
</span><span class="comment-delimiter">;; </span><span class="comment">2. permutation(p-digits(a(n, b))) should equal to a(n', b)
</span><span class="comment-delimiter">;;    </span><span class="comment">a.k.a. digits of a(n, b) should equal to a(n', b)
</span><span class="comment-delimiter">;;</span><span class="comment">
</span>
(<span class="keyword">defun</span> <span class="function-name">count-p-digits</span> (n <span class="type">&amp;optional</span> (base 10))
  <span class="doc">"Return an array of BASE size for each digits of N. "</span>
  (<span class="keyword">let</span> ((ad (make-array base <span class="builtin">:initial-element</span> 0 <span class="builtin">:element-type</span> 'unsigned-byte)))
    (<span class="keyword">dolist</span> (d (p-digits n base) ad) (incf (aref ad d)))))

(<span class="keyword">defun</span> <span class="function-name">array=</span> (arr1 arr2)
  <span class="doc">"Test if two array ARR1 and ARR2 is equal. "</span>
  (and (= (length arr1) (length arr2))
       (and-repeat (i (length arr1))
         (= (aref arr1 i) (aref arr2 i)))))

(<span class="keyword">defun</span> <span class="function-name">p-digits-permutate-p</span> (a b <span class="type">&amp;optional</span> (base 10))
  <span class="doc">"Test if A and B is permutable digits. "</span>
  (array= (count-p-digits a base) (count-p-digits b base)))

(<span class="keyword">defun</span> <span class="function-name">problem49</span> ()
  <span class="doc">"Return n digits. "</span>
  (<span class="keyword">multiple-value-bind</span> (p0 i0) (nearest-prime 1000 <span class="builtin">:right</span>)
    (<span class="keyword">loop</span> for i from i0
          for p  = p0 then (nth-prime i)
          for ps = (<span class="keyword">loop</span> for q from (+ p 3330) below 9999 by 3330
                         if (and (primep q) (p-digits-permutate-p p q))
                           collect q)
          if (= (length ps) 2)
            collect (int&lt;-p-digits (cons p ps) 10000)
          while (&lt; p (- 9999 (* 2 3330))))))

<hr />
<span class="comment-delimiter">;;; </span><span class="comment">Problem 50. Consecutive Prime Sum
</span><span class="comment-delimiter">;; </span><span class="comment">The prime 41, can be written as the sum of six consecutive primes:
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;;    </span><span class="comment">41 = 2 + 3 + 5 + 7 + 11 + 13.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">This is the longest sum of consecutive primes that adds to a prime
</span><span class="comment-delimiter">;; </span><span class="comment">below one-hundred.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">The longest sum of consecutive primes below one-thousand that adds
</span><span class="comment-delimiter">;; </span><span class="comment">to a prime, contains 21 terms, and is equal to 953.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">Which prime, below one-million, can be written as the sum of the
</span><span class="comment-delimiter">;; </span><span class="comment">most consecutive primes?
</span><span class="comment-delimiter">;;</span><span class="comment">
</span>
(<span class="keyword">defun</span> <span class="function-name">problem50</span> (<span class="type">&amp;optional</span> (max +million+))
  <span class="doc">"Return the prime that can be written as sum of the consecutive primes. "</span>
  (<span class="keyword">loop</span> for lefts on (<span class="keyword">loop</span> with sum = 0
                           for i from 1
                           for p = (nth-prime i)
                           while (&lt; (+ sum p) max)
                           do (incf sum p)
                           collect p)
        maximize (<span class="keyword">loop</span> with stfel = (reverse lefts)
                       for primes on stfel
                       for sum = (sum primes)
                       if (primep sum)
                         return sum
                       finally (<span class="keyword">return</span> 0))))

<hr />
<span class="comment-delimiter">;;; </span><span class="comment">Problem 51. Prime Digit Replacements
</span><span class="comment-delimiter">;; </span><span class="comment">By replacing the 1st digit of the 2-digit number *3, it turns out
</span><span class="comment-delimiter">;; </span><span class="comment">that six of the nine possible values: 13, 23, 43, 53, 73 and 83,
</span><span class="comment-delimiter">;; </span><span class="comment">are all prime.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">By replacing the 3rd and 4th digits of 56**3 with the same digit,
</span><span class="comment-delimiter">;; </span><span class="comment">this 5-digit number is the first example having seven primes among
</span><span class="comment-delimiter">;; </span><span class="comment">the ten generated numbers, yielding the family: 56003, 56113,
</span><span class="comment-delimiter">;; </span><span class="comment">56333, 56443, 56663, 56773, and 56993. Consequently 56003, being
</span><span class="comment-delimiter">;; </span><span class="comment">the first member of this family, is the smallest prime with this
</span><span class="comment-delimiter">;; </span><span class="comment">property.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">Find the smallest prime which, by replacing part of the number
</span><span class="comment-delimiter">;; </span><span class="comment">(not necessarily adjacent digits) with the same digit, is part
</span><span class="comment-delimiter">;; </span><span class="comment">of an eight prime value family.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span>
(<span class="keyword">defun</span> <span class="function-name">p-digit-mask</span> (n i <span class="type">&amp;optional</span> (base 10))
  <span class="doc">"Mask number N at I (lower to higher) digits.

Example:

    (p-digit-mask 123 1) ; =&gt; 103
"</span>
  (<span class="keyword">declare</span> (type (integer 0) n i base))
  (<span class="keyword">let*</span> ((cut1 (expt base i))
         (cut2 (* base cut1)))
    (+ (* cut2 (floor (/ n cut2))) (mod n cut1))))

(<span class="keyword">defun</span> <span class="function-name">p-digit-replace</span> (n i d <span class="type">&amp;optional</span> (base 10))
  <span class="doc">"Replace number N's Ith digits with D.

Example:

     (p-digit-replace 123 1 4) ; =&gt; 143
     (p-digit-replace 123 1 0) ; =&gt; should equal to (p-digit-mask 123 1)

"</span>
  (<span class="keyword">declare</span> (type (integer 0) n i base))
  (<span class="keyword">let*</span> ((cut1 (expt base i))
         (cut2 (* base cut1)))
    (+ (* cut2 (floor (/ n cut2)))
       (* d cut1)
       (mod n cut1))))

(<span class="keyword">defun</span> <span class="function-name">p-digit-replace*</span> (n i-list d <span class="type">&amp;optional</span> (base 10))
  <span class="doc">"Replace N at I-LIST position by D. "</span>
  (reduce (rcurry* #'p-digit-replace d base) i-list <span class="builtin">:initial-value</span> n))

(<span class="keyword">defun</span> <span class="function-name">count-prime-of-p-digit-replace*</span> (n i-list <span class="type">&amp;key</span> (base 10) (replace (range-list 0 9)))
  <span class="doc">"Count number of prime numbers by replacing N at I-LIST position with REPLACE. "</span>
  (<span class="keyword">loop</span> with digits = (count-digits n base)
        for rep in replace
        for new = (p-digit-replace* n i-list rep base)
        if (and (= (count-digits new base) digits) (primep new))
          collect new into primes
          and count new into len
        finally (<span class="keyword">return</span> (values len primes))))

(<span class="keyword">defun</span> <span class="function-name">problem51</span> (<span class="type">&amp;optional</span> (len 8))
  (<span class="keyword">loop</span> for i from 1
        for p = (nth-prime i)
        for d = (count-digits p)
        do (<span class="keyword">loop</span> with can-pick = (range-list 0 (1- d))
                 for pick from 1 below d
                 do (<span class="keyword">loop</span> for replace in (n-pick-list can-pick pick)
                          do (<span class="keyword">multiple-value-bind</span> (count primes)
                                 (count-prime-of-p-digit-replace* p replace)
                               (<span class="keyword">when</span> (= count len)
                                 (<span class="keyword">return-from</span> problem51 primes)))))))

<hr />
<span class="comment-delimiter">;;; </span><span class="comment">Problem 52. Permuted Multiples
</span><span class="comment-delimiter">;; </span><span class="comment">It can be seen that the number, 125874, and its double, 251748,
</span><span class="comment-delimiter">;; </span><span class="comment">contain exactly the same digits, but in a different order.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">Find the smallest positive integer, x, such that 2 * x, 3 * x, 4 * x,
</span><span class="comment-delimiter">;; </span><span class="comment">5 * x, and 6 * x, contain the same digits.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span>
<span class="comment-delimiter">;; </span><span class="comment">Note that if x, 2x, 3x, 4x, 5x, and 6x should
</span>
(<span class="keyword">defun</span> <span class="function-name">problem52</span> (<span class="type">&amp;optional</span> (n 6))
  <span class="doc">"Return the smallest positive integer having the same digits. "</span>
  (<span class="keyword">loop</span> for start = 10 then (* 10 start) do
    (<span class="keyword">loop</span> for x from (1+ start) upto (floor (* 10 start) 6)
          for xd = (count-p-digits x)
          if (and-repeat (i 2 n) (array= xd (count-p-digits (* i x))))
            do (<span class="keyword">return-from</span> problem52 x))))

<hr />
<span class="comment-delimiter">;;; </span><span class="comment">Problem 53. Combinatoric Selections
</span><span class="comment-delimiter">;; </span><span class="comment">There are exactly ten ways of selecting three from five, 12345:
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;;    </span><span class="comment">123, 124, 125, 135, 135, 145, 234, 235, 245, and 345
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;;                                                  </span><span class="comment">/ 5 \
</span><span class="comment-delimiter">;; </span><span class="comment">In combinatorics, we use the notation, C(n, r) = |   | = 10.
</span><span class="comment-delimiter">;;                                                  </span><span class="comment">\ 3 /
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">In general, C(n, r) = n! / r! (n - r)!, where r &lt;= n,
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;;   </span><span class="comment">n! = n * (n - 1) * ... * 3 * 2 * 1, and 0! = 1.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">It is not until n = 23, that a value exceeds one-million:
</span><span class="comment-delimiter">;; </span><span class="comment">C(23, 10) = 1144066.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">How many, not necessarily distinct, values of C(n, r) for
</span><span class="comment-delimiter">;; </span><span class="comment">1 &lt;= n &lt;= 100, are greater than one-million?
</span><span class="comment-delimiter">;;</span><span class="comment">
</span>
(<span class="keyword">defun</span> <span class="function-name">choices</span> (n r)
  <span class="doc">"Return the C(n, r) = n! / r! (n - r)!. "</span>
  (<span class="keyword">declare</span> (type unsigned-byte n r))
  (<span class="warning">assert</span> (&lt;= r n))
  (/ (factorial n) (* (factorial r) (factorial (- n r)))))

(<span class="keyword">defun</span> <span class="function-name">problem53</span> (<span class="type">&amp;optional</span> (max 100) (limit +million+))
  <span class="doc">"Count C(n, r) &gt; million for 1 &lt;= n &lt;= MAX. "</span>
  (<span class="keyword">loop</span> with cnt = 0
        for n from 1 upto max
        for rmax = (ceiling n 2)
        do (<span class="keyword">loop</span> for r from 1 upto rmax
                 if (&gt; (choices n r) limit)
                   return (incf cnt (1+ (- n (* 2 r)))))
        finally (<span class="keyword">return</span> cnt)))

<hr />
<span class="comment-delimiter">;; </span><span class="comment">Problem 54. Poker Hands
</span><span class="comment-delimiter">;; </span><span class="comment">In the card game poker, a hand consists of five cards and are ranked,
</span><span class="comment-delimiter">;; </span><span class="comment">from lowest to highest, in the following way:
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">+ High Card:       Highest value card
</span><span class="comment-delimiter">;; </span><span class="comment">+ One Pair:        Two cards of the same value
</span><span class="comment-delimiter">;; </span><span class="comment">+ Two Pairs:       Two different pairs
</span><span class="comment-delimiter">;; </span><span class="comment">+ Three of a Kind: Three cards of the same value
</span><span class="comment-delimiter">;; </span><span class="comment">+ Straight:        All cards are consecutive values
</span><span class="comment-delimiter">;; </span><span class="comment">+ Flush:           All cards of the same suit
</span><span class="comment-delimiter">;; </span><span class="comment">+ Full House:      Three of a kind and a pair
</span><span class="comment-delimiter">;; </span><span class="comment">+ Four of a Kind:  Four cards of the same value
</span><span class="comment-delimiter">;; </span><span class="comment">+ Straight Flush:  All cards are consecutive values of same suit
</span><span class="comment-delimiter">;; </span><span class="comment">+ Royal Flush:     Ten, Jack, Queen, King, Ace, in same suit.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">The cards are valued in the order:
</span><span class="comment-delimiter">;; </span><span class="comment">2, 3, 4, 5, 6, 7, 8, 9, 10, Jack, Queen, King, Ace.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">If two players have the same ranked hands then the rank made up
</span><span class="comment-delimiter">;; </span><span class="comment">of the highest value wins: for example, a pair of eight beats
</span><span class="comment-delimiter">;; </span><span class="comment">a pair of queens, then highest cards in each hand are compared
</span><span class="comment-delimiter">;; </span><span class="comment">(see example 4 below); if the highest cards tie then the next
</span><span class="comment-delimiter">;; </span><span class="comment">highest cards are compared, and so on.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">Consider the following five hands dealt to two players:
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;;     </span><span class="comment">Hand      Player 1          Player 2         Winner
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;;      </span><span class="comment">1     5H 5C 6S 7S KD    2C 3S 8S 8D TD     Player 2
</span><span class="comment-delimiter">;;            </span><span class="comment">Pair of Fives     Pair of Eights
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;;      </span><span class="comment">2     5D 8C 9S JS AC    2C 5C 7D 8S QH     Player 1
</span><span class="comment-delimiter">;;           </span><span class="comment">Highest card Ace  Highest card Queen
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;;      </span><span class="comment">3     2D 9C AS AH AC    3D 6D 7D TD QD     Player 2
</span><span class="comment-delimiter">;;              </span><span class="comment">Three Aces     Flush with Diamonds
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;;      </span><span class="comment">4     4D 6S 9H QH QC    3D 6D 7H QD QS     Player 1
</span><span class="comment-delimiter">;;            </span><span class="comment">Pair of Queens    Pair of Queens
</span><span class="comment-delimiter">;;          </span><span class="comment">Highest card Nine  Highest card Seven
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;;      </span><span class="comment">5     2H 2D 4C 4D 4S    3C 3D 3S 9S 9D     Player 1
</span><span class="comment-delimiter">;;              </span><span class="comment">Full House        Full House
</span><span class="comment-delimiter">;;           </span><span class="comment">With Three Fours  with Three Threes
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">The file, poker.txt, contains one-thousand random hands
</span><span class="comment-delimiter">;; </span><span class="comment">dealt to two players. Each line of the file contains ten
</span><span class="comment-delimiter">;; </span><span class="comment">cards (separated by a single space): the first five are
</span><span class="comment-delimiter">;; </span><span class="comment">Player 1's cards and the last five are Player 2's cards.
</span><span class="comment-delimiter">;; </span><span class="comment">You can assume that all hands are valid (no invalid
</span><span class="comment-delimiter">;; </span><span class="comment">characters or repeated cards), each player's hand is in
</span><span class="comment-delimiter">;; </span><span class="comment">no specific order, and in each hand there is a clear
</span><span class="comment-delimiter">;; </span><span class="comment">winner.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">How many hands does Player 1 win?
</span><span class="comment-delimiter">;;</span><span class="comment">
</span>
<span class="comment-delimiter">;; </span><span class="comment">just use `</span><span class="comment"><span class="constant">str</span></span><span class="comment">' package to cut down string manipulation time
</span>
(ql:quickload <span class="builtin">:str</span>)

(<span class="keyword">deftype</span> <span class="type">poker-card-color</span> ()
  '(member <span class="builtin">:hearts</span> <span class="builtin">:diamonds</span> <span class="builtin">:clubs</span> <span class="builtin">:spades</span>))

(<span class="keyword">deftype</span> <span class="type">poker-card-point</span> ()
  '(integer 2 14))

(<span class="keyword">defstruct</span> <span class="type">poker-card</span>
  (point 0       <span class="builtin">:type</span> poker-card-point)
  (color <span class="builtin">:hearts</span> <span class="builtin">:type</span> poker-card-color))

(<span class="keyword">defun</span> <span class="function-name">poker-card&lt;-string</span> (string)
  <span class="doc">"Turn poker card STRING into `</span><span class="doc"><span class="constant">poker-card</span></span><span class="doc">'. "</span>
  (<span class="keyword">declare</span> (type string string))
  (<span class="keyword">let</span> ((point (aref string 0))
        (color (aref string 1)))
    (make-poker-card <span class="builtin">:point</span> (<span class="keyword">cond</span> ((char= point #\A) 14)
                                  ((char= point #\K) 13)
                                  ((char= point #\Q) 12)
                                  ((char= point #\J) 11)
                                  ((char= point #\T) 10)
                                  (t (+ 2 (- (char-code point) (char-code #\2)))))
                     <span class="builtin">:color</span> (<span class="keyword">cond</span> ((char= color #\H) <span class="builtin">:hearts</span>)
                                  ((char= color #\D) <span class="builtin">:diamonds</span>)
                                  ((char= color #\C) <span class="builtin">:clubs</span>)
                                  ((char= color #\S) <span class="builtin">:spades</span>)))))

(<span class="keyword">defmethod</span> <span class="function-name">print-object</span> ((card poker-card) stream)
  (format stream <span class="string">"~C~C"</span>
          (<span class="keyword">cond</span> ((= (poker-card-point card) 10) #\T)
                ((= (poker-card-point card) 11) #\J)
                ((= (poker-card-point card) 12) #\Q)
                ((= (poker-card-point card) 13) #\K)
                ((= (poker-card-point card) 14) #\A)
                (t (code-char (+ (poker-card-point card) (char-code #\2) -2))))
          (<span class="keyword">ecase</span> (poker-card-color card)
            (<span class="builtin">:hearts</span>   #\H)
            (<span class="builtin">:diamonds</span> #\D)
            (<span class="builtin">:clubs</span>    #\C)
            (<span class="builtin">:spades</span>   #\S))))

(<span class="keyword">defun</span> <span class="function-name">read-poker-hands</span> (file)
  <span class="doc">"Read poker hands from FILE.
Return a list of (player1 player2). "</span>
  (<span class="keyword">with-open-file</span> (stream file)
    (<span class="keyword">loop</span> for line = (read-line stream nil nil) while line
          for hand = (mapcar #'poker-card&lt;-string (str:words line))
          collect (list (subseq hand 0 5) (subseq hand 5)))))

<span class="comment-delimiter">;; </span><span class="comment">Poker Hands Score
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;;    </span><span class="comment">15^0*02-14: High Card of 2-A
</span><span class="comment-delimiter">;;    </span><span class="comment">15^1*02-14: One Pair of 2-A
</span><span class="comment-delimiter">;;    </span><span class="comment">15^2*02-14: Second Pair of 2-A (max of second pair)
</span><span class="comment-delimiter">;;    </span><span class="comment">15^3*02-14: Three of a Kind value
</span><span class="comment-delimiter">;;    </span><span class="comment">15^4*02-14: Straight value
</span><span class="comment-delimiter">;;    </span><span class="comment">15^5*02-14: Flush, value of High Card
</span><span class="comment-delimiter">;;    </span><span class="comment">15^6*02-14: Full House:
</span><span class="comment-delimiter">;;    </span><span class="comment">15^7*02-14: Four of a Kind, value of four
</span><span class="comment-delimiter">;;    </span><span class="comment">15^8*02-14: Straight Flush, value of high card
</span><span class="comment-delimiter">;;    </span><span class="comment">15^9*1:     Royal Flush
</span><span class="comment-delimiter">;;</span><span class="comment">
</span>
(<span class="keyword">defun</span> <span class="function-name">poker-hands</span> (hands)
  <span class="doc">"Return Poker hands score and type. "</span>
  (<span class="keyword">destructuring-bind</span> (first . rest) hands
    (<span class="keyword">let</span> ((points (make-array 15 <span class="builtin">:initial-element</span> 0 <span class="builtin">:element-type</span> 'unsigned-byte))
          (color0 (poker-card-color first))
          (colorp t))
      (incf (aref points (poker-card-point first)))
      (<span class="keyword">dolist</span> (card rest)
        (incf (aref points (poker-card-point card)))
        (<span class="keyword">unless</span> (eq color0 (poker-card-color card))
          (setf colorp nil)))
      (<span class="keyword">when</span> colorp
        (<span class="keyword">when</span> (and-repeat (point 10 14)
                (= (aref points point) 1))
          (<span class="keyword">return-from</span> poker-hands
            (values (expt 15 9) <span class="builtin">:royal-flush</span>))))
      (<span class="keyword">loop</span> with 2i1 = 0 with 2i2 = 0 with 3i  = 0
            for i from 2 upto 14
            for c = (aref points i)
            if (and colorp (= c 5))
              do (<span class="keyword">return-from</span> poker-hands
                   (values (* (expt 15 8) i) <span class="builtin">:straight-flush</span>))
            if (= c 4)
              do (<span class="keyword">return-from</span> poker-hands
                   (values (* (expt 15 7) i) <span class="builtin">:four-of-a-kind</span>))
            if (= c 3)
              do (setf 3i i)
            if (= c 2)
              do (<span class="keyword">if</span> (zerop 2i1)
                     (setf 2i1 i)
                     (<span class="keyword">let</span> ((min (min 2i1 i))
                           (max (max 2i1 i)))
                       (setf 2i1 min)
                       (setf 2i2 max)))
            if (/= c 0)
              maximize i into high-card
              and minimize i into row-start
            finally (<span class="keyword">return</span>
                      (<span class="keyword">let</span> ((type <span class="builtin">:high-card</span>))
                        (values (+ high-card
                                   (<span class="keyword">if</span> (zerop 2i1)
                                       0
                                       (<span class="keyword">progn</span> (setf type <span class="builtin">:one-pair</span>)
                                              (* 15 2i1)))
                                   (<span class="keyword">if</span> (zerop 2i2)
                                       0
                                       (<span class="keyword">progn</span> (setf type <span class="builtin">:two-pairs</span>)
                                              (* (expt 15 2) 2i2)))
                                   (<span class="keyword">if</span> (zerop 3i)
                                       0
                                       (<span class="keyword">progn</span> (setf type <span class="builtin">:three-of-a-kind</span>)
                                              (* (expt 15 3) 3i)))
                                   (<span class="keyword">if</span> (<span class="keyword">loop</span> for i from row-start upto 14
                                             while (= 1 (aref points i))
                                             count i into continue
                                             finally (<span class="keyword">return</span> (= continue 5)))
                                       (<span class="keyword">progn</span> (setf type <span class="builtin">:straight</span>)
                                              (* (expt 15 4) (+ row-start 5)))
                                       0)
                                   (<span class="keyword">if</span> colorp
                                       (<span class="keyword">progn</span> (setf type <span class="builtin">:flush</span>)
                                              (* (expt 15 5) high-card))
                                       0)
                                   (<span class="keyword">if</span> (and (/= 2i2 0) (/= 3i 0))
                                       (<span class="keyword">progn</span> (setf type <span class="builtin">:full-house</span>)
                                              (expt 15 6))
                                       0))
                                type)))))))

(<span class="keyword">defun</span> <span class="function-name">problem54</span> ()
  <span class="doc">"Count how many times Player 1 wins. "</span>
  (<span class="keyword">loop</span> for (player1 player2) in (read-poker-hands <span class="string">"./dat/0054_poker.txt"</span>)
        for score1 = (poker-hands player1)
        for score2 = (poker-hands player2)
        count (&gt; score1 score2)))

<hr />
<span class="comment-delimiter">;;; </span><span class="comment">Problem 55. Lychrel Numbers
</span><span class="comment-delimiter">;; </span><span class="comment">If we take 47, reverse and add, 47 + 74 = 121, which is palindromic.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">Not all numbers produce palindromes so quickly. For example,
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;;      </span><span class="comment">349 +  943 = 1292
</span><span class="comment-delimiter">;;     </span><span class="comment">1292 + 2921 = 4213
</span><span class="comment-delimiter">;;     </span><span class="comment">4213 + 3124 = 7337
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">That is, 349 took three iterations to arrive at a palindrome.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">Although no one has proved it yet, it is thought that some
</span><span class="comment-delimiter">;; </span><span class="comment">numbers, like 196, never produce a palindrome. A number that
</span><span class="comment-delimiter">;; </span><span class="comment">never forms a palindrome through the reverse and add process
</span><span class="comment-delimiter">;; </span><span class="comment">is called Lychrel number. Due to the theoretical nature of
</span><span class="comment-delimiter">;; </span><span class="comment">these numbers, and for the purpose of this problem, we shall
</span><span class="comment-delimiter">;; </span><span class="comment">assume that a number is Lychrel until proven otherwise. In
</span><span class="comment-delimiter">;; </span><span class="comment">addition you are given that for every number below ten-thousand,
</span><span class="comment-delimiter">;; </span><span class="comment">it will either:
</span><span class="comment-delimiter">;; </span><span class="comment">(i) become a palindrome in less than fifty iterations, or
</span><span class="comment-delimiter">;; </span><span class="comment">(ii) no one, with all the computing power that exists, has
</span><span class="comment-delimiter">;; </span><span class="comment">managed so far to map it to a palindrome.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">In fact, 10677 is the first number to be shown to require over
</span><span class="comment-delimiter">;; </span><span class="comment">fifty iterations before producing a palidrome:
</span><span class="comment-delimiter">;; </span><span class="comment">4668731596684224866951378664 (53 iterations, 28-digits).
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">Surprisingly, there are palindromic numbers that are themselves
</span><span class="comment-delimiter">;; </span><span class="comment">Lychrel numbers; the first example is 4994.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">How many Lychrel numbers are there below ten-thousand?
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">NOTE: Wording was modified slightly on 24 April 2007 to emphasise
</span><span class="comment-delimiter">;; </span><span class="comment">the theoretical nature of Lychrel numbers.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span>
(<span class="keyword">defun</span> <span class="function-name">lychrel-number-p</span> (num <span class="type">&amp;optional</span> (iteration 50))
  <span class="doc">"Test if NUM is Lychrel Number within ITERATION. "</span>
  (<span class="keyword">if</span> (zerop iteration) t
      (<span class="keyword">let</span> ((num (+ num (int&lt;-p-digits (reverse (p-digits num))))))
        (<span class="keyword">unless</span> (palindromep num)
          (lychrel-number-p num (1- iteration))))))

(<span class="keyword">defun</span> <span class="function-name">problem55</span> (<span class="type">&amp;optional</span> (max (* 10 +thousand+)))
  <span class="doc">"Count Lychrel numbers below ten-thousand. "</span>
  (<span class="keyword">loop</span> for i from 1 below max
        count (lychrel-number-p i)))

<hr />
<span class="comment-delimiter">;;; </span><span class="comment">Problem 56. Powerful Digit Sum
</span><span class="comment-delimiter">;; </span><span class="comment">A googol (10^100) is massive number: one followed by one-hundred
</span><span class="comment-delimiter">;; </span><span class="comment">zeros; 100^100 is almost unimaginably large: one followed by two-hundred
</span><span class="comment-delimiter">;; </span><span class="comment">zeros. Despite their size, the sum of the digits in each number is
</span><span class="comment-delimiter">;; </span><span class="comment">only 1.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">Considering natural of the form, a^b, where a, b &lt; 100, what is the
</span><span class="comment-delimiter">;; </span><span class="comment">maximum digital sum.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span>
(<span class="keyword">defun</span> <span class="function-name">problem56</span> (<span class="type">&amp;optional</span> (max 100))
  <span class="doc">"Return the max (sum (p-digits (expt a b))). "</span>
  (<span class="keyword">loop</span> for b from 2 below max
        maximize (<span class="keyword">loop</span> for a from 1 below max
                       maximize (sum (p-digits (expt a b))))))

<hr />
<span class="comment-delimiter">;;; </span><span class="comment">Problem 57. Square Root Convergents
</span><span class="comment-delimiter">;; </span><span class="comment">It is possible to show that the square root of two can be expressed as
</span><span class="comment-delimiter">;; </span><span class="comment">an infinite continued fraction.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;;       </span><span class="comment">sqrt(2) = 1 + 1 / (2 + 1 / (2 + 1 / (2 + ... )))
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">By expanding this for the first four iterations, we get:
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;;  </span><span class="comment">1 + 1/2                         =  3/2  = 1.5
</span><span class="comment-delimiter">;;  </span><span class="comment">1 + 1/(2 + 1/2)                 =  7/5  = 1.4
</span><span class="comment-delimiter">;;  </span><span class="comment">1 + 1/(2 + 1/(2 + 1/2))         = 17/12 = 1.41666...
</span><span class="comment-delimiter">;;  </span><span class="comment">1 + 1/(2 + 1/(2 + 1/(2 + 1/2))) = 41/29 = 1/41379...
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">The next three expansions are 99/70, 239/169, and 577/408, but
</span><span class="comment-delimiter">;; </span><span class="comment">the eighth expansion, 1393/985, is the first example where
</span><span class="comment-delimiter">;; </span><span class="comment">the number of digits in the numerator exceeds the number of
</span><span class="comment-delimiter">;; </span><span class="comment">digits in the denominator.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">In the first one-thousand expansions, how many fractions
</span><span class="comment-delimiter">;; </span><span class="comment">contain a numerator with more digits than the denominator?
</span><span class="comment-delimiter">;;</span><span class="comment">
</span>
<span class="comment-delimiter">;; </span><span class="comment">x(n+1) = 1/(1 + x(n))
</span>
(<span class="keyword">defun</span> <span class="function-name">square-root-2-frac-iteration</span> (frac)
  <span class="doc">"Iterate on 1 + 1/(2 + 1/(2 + 1/(2 + ...))). "</span>
  (<span class="keyword">declare</span> (type rational frac))
  (1+ (/ (1+ frac))))

(<span class="keyword">defun</span> <span class="function-name">problem57</span> (<span class="type">&amp;optional</span> (max +thousand+))
  <span class="doc">"Count numerator digits &gt; denominator digits. "</span>
  (<span class="keyword">loop</span> repeat max
        for xi = 3/2 then (square-root-2-frac-iteration xi)
        for num = (numerator   xi)
        for den = (denominator xi)
        count (&gt; (count-digits num) (count-digits den))))

<hr />
<span class="comment-delimiter">;;; </span><span class="comment">Problem 58. Spiral Primes
</span><span class="comment-delimiter">;; </span><span class="comment">Starting with 1 and spiralling anticlockwise in the following way,
</span><span class="comment-delimiter">;; </span><span class="comment">a square spiral with side length 7 is formed.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;;        </span><span class="comment">37 36 35 34 33 32 31
</span><span class="comment-delimiter">;;        </span><span class="comment">38 17 16 15 14 13 30
</span><span class="comment-delimiter">;;        </span><span class="comment">39 18  5  4  3 12 29
</span><span class="comment-delimiter">;;        </span><span class="comment">40 19  6  1  2 11 28
</span><span class="comment-delimiter">;;        </span><span class="comment">41 20  7  8  9 10 27
</span><span class="comment-delimiter">;;        </span><span class="comment">42 21 22 23 24 25 26
</span><span class="comment-delimiter">;;        </span><span class="comment">43 44 45 46 47 48 49
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">It is interesting to note that the odd seuares lie along the bottom
</span><span class="comment-delimiter">;; </span><span class="comment">right diagonal, but what is more interesting is that 8 out of the
</span><span class="comment-delimiter">;; </span><span class="comment">13 numbers lying along both diagonals are pime; that is, a ratio
</span><span class="comment-delimiter">;; </span><span class="comment">of 8/13 = 62%.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">If one complete new layer is wrapped around the spiral above, a
</span><span class="comment-delimiter">;; </span><span class="comment">square spiral with side length 9 will be formed. If this process
</span><span class="comment-delimiter">;; </span><span class="comment">is continued, what is the side length of the square spiral for
</span><span class="comment-delimiter">;; </span><span class="comment">which the ratio of primes along both diagonals first falls below
</span><span class="comment-delimiter">;; </span><span class="comment">10%.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span>
<span class="comment-delimiter">;; </span><span class="comment">see `</span><span class="comment"><span class="constant">problem28</span></span><span class="comment">'
</span>
(<span class="keyword">defun</span> <span class="function-name">make-spiral-corners-iterator</span> ()
  <span class="doc">"Make a iterator function that return a list of corners and nth layer. "</span>
  (<span class="keyword">let</span> ((layer 2)
        (num   1)
        (width 3))
    (<span class="keyword">lambda</span> ()
      (<span class="keyword">loop</span> with corners = (list (incf num (1+ (- width 2))))
            repeat 3
            do (push (incf num (1- width)) corners)
            finally (<span class="keyword">return</span> (<span class="keyword">unwind-protect</span> (values corners layer)
                              (incf layer)
                              (incf width 2)))))))

(<span class="keyword">defun</span> <span class="function-name">select</span> (testf sequence <span class="type">&amp;key</span> key)
  <span class="doc">"Select by TESTF on SEQUENCE. "</span>
  (remove-if-not testf sequence <span class="builtin">:key</span> key))

(<span class="keyword">defun</span> <span class="function-name">problem58</span> (<span class="type">&amp;optional</span> (start 4) (limit 0.1))
  <span class="doc">"Return the sum of the diagonals. "</span>
  (<span class="keyword">loop</span> with iter = (make-spiral-corners-iterator)
        for (corners layer) = (multiple-value-list (funcall iter))
        for total  from 5 by 4
        for primes = (count-if #'primep corners)
          then (+ primes (count-if #'primep corners))
        while (or (&lt; layer start)
                  (&gt;= (/ primes total) limit))
        finally (<span class="keyword">return</span> (values (1- (* 2 layer)) (/ primes total)))))

<hr />
<span class="comment-delimiter">;;; </span><span class="comment">Problem 59. XOR Decryption
</span><span class="comment-delimiter">;; </span><span class="comment">Each character on a computer is assigned a unique code and the preferred
</span><span class="comment-delimiter">;; </span><span class="comment">standard is ASCII (American Standard Code for Information Interchange).
</span><span class="comment-delimiter">;; </span><span class="comment">For example, uppercase A = 65, asterisk (*) = 42, and lowercase k = 107.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">A modern encryptioin method is to take a text file, convert the bytes
</span><span class="comment-delimiter">;; </span><span class="comment">to ASCII, then XOR each byte with a given value, taken from a secret key.
</span><span class="comment-delimiter">;; </span><span class="comment">The advantage with the XOR function is that using the same encryption key
</span><span class="comment-delimiter">;; </span><span class="comment">on the cipher text, restores the plain text; for example, 65 XOR 42 = 107,
</span><span class="comment-delimiter">;; </span><span class="comment">then 107 XOR 42 = 65.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">For unbreakable encryption, the key is the same length as the plain text
</span><span class="comment-delimiter">;; </span><span class="comment">message, and teh key is made up of random bytes. The user would keep the
</span><span class="comment-delimiter">;; </span><span class="comment">encrypted message and the encryption key in different locations, and
</span><span class="comment-delimiter">;; </span><span class="comment">without both "halves", it is impossible to decrypt the message.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">Unfortunately, this method is impractical for most users, so the modified
</span><span class="comment-delimiter">;; </span><span class="comment">method is to use a password as a key. If the password is shorter than the
</span><span class="comment-delimiter">;; </span><span class="comment">message, which is likely, the key is repeated cyclically thoughout the
</span><span class="comment-delimiter">;; </span><span class="comment">message. The balance for this method is using a sufficiently long password
</span><span class="comment-delimiter">;; </span><span class="comment">key for security, but short enough to be memorable.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">Your task has been made easy, as the encryption key consists of three lower
</span><span class="comment-delimiter">;; </span><span class="comment">case characters. Using ./dat/0059_cipher.sexp, a file containing the
</span><span class="comment-delimiter">;; </span><span class="comment">encrypted ASCII codes, and the knowledge that the plain text must contain
</span><span class="comment-delimiter">;; </span><span class="comment">common English words, decrypt the message and find the sum of the ASCII
</span><span class="comment-delimiter">;; </span><span class="comment">values in the original text.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span>
(<span class="keyword">defun</span> <span class="function-name">xor-list</span> (list1 list2)
  <span class="doc">"XOR each element for LIST1 and LIST2.
If one list is shorter than another list, windowed map it. "</span>
  (<span class="keyword">let</span> ((len1 (length list1))
        (len2 (length list2)))
    (<span class="keyword">cond</span> ((= len1 len2)
           (mapcar #'logxor list1 list2))
          ((&lt; len1 len2)
           (apply #'append
                  (windowed-mapcar
                   (compose (curry #'xor-list list1) #'args) len1 list2 len1)))
          (t
           (apply #'append
                  (windowed-mapcar
                   (compose (curry #'xor-list list2) #'args) len2 list1 len2))))))

<span class="comment-delimiter">;; </span><span class="comment">Just need some brute force to manually fine tuning FIRST-N
</span><span class="comment-delimiter">;; </span><span class="comment">to cut down the time (since the `</span><span class="comment"><span class="constant">english-like-p</span></span><span class="comment">' is not so
</span><span class="comment-delimiter">;; </span><span class="comment">easy to determine
</span>
(<span class="keyword">defun</span> <span class="function-name">problem59</span> ()
  <span class="doc">"Decrypt the message. "</span>
  (<span class="keyword">let</span> ((message (read-file <span class="string">"./dat/0059_cipher.sexp"</span>)))
    (<span class="keyword">flet</span> ((english-like-p (string)
             (and-repeat (i (length string))
               (<span class="keyword">let</span> ((chr (aref string i)))
                 (or (char&lt;= #\A chr #\Z)
                     (char&lt;= #\a chr #\z)
                     (char&lt;= #\0 chr #\9)
                     (find chr '(#\Space #\" #\/ #\, #\' #\( #\)
                                 #\[ #\] #\+ #\- #\: #\; #\.)
                           <span class="builtin">:test</span> #'char=))))))
      (<span class="keyword">loop</span> for p1 from (char-code #\a) upto (char-code #\z) do
        (<span class="keyword">loop</span> for p2 from (char-code #\a) upto (char-code #\z) do
          (<span class="keyword">loop</span> for p3 from (char-code #\a) upto (char-code #\z)
                for passwd = (list p1 p2 p3)
                for dec = (xor-list passwd message)
                if (english-like-p (map 'string #'code-char dec))
                  do (<span class="keyword">return-from</span> problem59
                       (values (sum dec)
                               (map 'string #'code-char passwd)
                               (map 'string #'code-char dec)))))))))

<hr />
<span class="comment-delimiter">;;; </span><span class="comment">Problem 60. Prime Pair Sets
</span><span class="comment-delimiter">;; </span><span class="comment">The primes 3, 7, 109, and 673, are quite remarkable. By taking any
</span><span class="comment-delimiter">;; </span><span class="comment">two primes and concatenating them in any order the result will
</span><span class="comment-delimiter">;; </span><span class="comment">always be prime. For example, taking 7 and 109, both 7109 and 1097
</span><span class="comment-delimiter">;; </span><span class="comment">are prime. The sum of these four primes, 792, represents the lowest
</span><span class="comment-delimiter">;; </span><span class="comment">sum for a set of four primes with this property.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">Find the lowest sum for a set of five primes for which any two
</span><span class="comment-delimiter">;; </span><span class="comment">primes concatenate to produce another prime.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span>
(<span class="keyword">defun</span> <span class="function-name">p-digit-concate</span> (n1 n2 <span class="type">&amp;optional</span> (base 10))
  <span class="doc">"Concatenate N1 and N2. "</span>
  (int&lt;-p-digits (append (p-digits n1 base) (p-digits n2 base)) base))

(<span class="keyword">defun</span> <span class="function-name">any-p-digit-concate-prime-p</span> (primes)
  <span class="doc">"Test if any p-digit-concate of PRIMES are prime. "</span>
  (and-dolist (p1p2 (n-pick-list primes 2))
    (primep (apply #'p-digit-concate p1p2))))

<span class="comment-delimiter">;; </span><span class="comment">Algorithm:
</span><span class="comment-delimiter">;; </span><span class="comment">p-concate-prime-p(p1, p2) = (primep * p-digit-concate) (p1, p2)
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">find-primes(0) = ()
</span><span class="comment-delimiter">;; </span><span class="comment">find-primes(1) = (any prime)
</span><span class="comment-delimiter">;; </span><span class="comment">find-primes(2) = (p1, p2 that is p-concate-prime-p(p1, p2))
</span><span class="comment-delimiter">;; </span><span class="comment">find-primes(n) = (p1..pn-1, pn that is p-concate-prime-p(pi, pn), i = 1, n-1)
</span><span class="comment-delimiter">;;</span><span class="comment">
</span>
(<span class="keyword">defun</span> <span class="function-name">problem60</span> (<span class="type">&amp;optional</span> (n 5) (limit 1100))
  <span class="doc">"Search for N more primes that could make them with PRIMES
any-p-digit-concate-prime. "</span>
  (<span class="keyword">labels</span> ((find-primes (rest primes start)
             (<span class="keyword">if</span> (zerop rest) primes
                 (<span class="keyword">loop</span> for i from start below limit for p1 = (nth-prime i)
                       if (and-dolist (p2 primes)
                            (and (primep (p-digit-concate p1 p2))
                                 (primep (p-digit-concate p2 p1))))
                         do (<span class="keyword">let</span> ((primes (find-primes
                                           (1- rest) (cons p1 primes) (1+ i))))
                              (<span class="keyword">when</span> primes
                                (<span class="keyword">return</span> primes)))))))
    (sum (find-primes n () 2))))

<span class="comment-delimiter">;;; </span><span class="comment">Problem 61. Cyclical Figurate Numbers
</span><span class="comment-delimiter">;; </span><span class="comment">Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal
</span><span class="comment-delimiter">;; </span><span class="comment">numbers are all figurate (polygonal) numbers and are generated by
</span><span class="comment-delimiter">;; </span><span class="comment">the following formulae:
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;;  </span><span class="comment">Triangle     P(3, n) = n * (n + 1) / 2        1, 3,  6, 10, 15, ...
</span><span class="comment-delimiter">;;  </span><span class="comment">Square       P(4, n) = n^2                    1, 4,  9, 16, 25, ...
</span><span class="comment-delimiter">;;  </span><span class="comment">Pentagonal   P(5, n) = n * (3 * n - 1) / 2    1, 5, 12, 22, 35, ...
</span><span class="comment-delimiter">;;  </span><span class="comment">Hexagonal    P(6, n) = n * (2 * n - 1)        1, 6, 15, 28, 45, ...
</span><span class="comment-delimiter">;;  </span><span class="comment">Heptagonal   P(7, n) = n * (5 * n - 3) / 2    1, 7, 18, 34, 55, ...
</span><span class="comment-delimiter">;;  </span><span class="comment">Octagonal    P(8, n) = n * (3 * n - 2)        1, 8, 21, 40, 65, ...
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">The ordered set of three 4-digit numbers: 8128, 2882, 8281, has
</span><span class="comment-delimiter">;; </span><span class="comment">three interesting properties.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;;  </span><span class="comment">1. The set is cyclic, in that the last two digits of each number
</span><span class="comment-delimiter">;;     </span><span class="comment">is the first two digits of the next number (including the last
</span><span class="comment-delimiter">;;     </span><span class="comment">number with the first).
</span><span class="comment-delimiter">;;  </span><span class="comment">2. Each polygonal type: triangle (P(3, 127) = 8128), square
</span><span class="comment-delimiter">;;     </span><span class="comment">(P(4, 91) = 8281), and pentagonal (P(5, 44) = 2882), is
</span><span class="comment-delimiter">;;     </span><span class="comment">represented by a different number in the set.
</span><span class="comment-delimiter">;;  </span><span class="comment">3. This is the only set of 4-digit numbers with this property.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">Find the sum of the only ordered set of six cyclic 4-digit numbers
</span><span class="comment-delimiter">;; </span><span class="comment">for which each polygonal type: triangle, square, pentagonal,
</span><span class="comment-delimiter">;; </span><span class="comment">hexagonal, heptagonal, and octagonal, is represented by a different
</span><span class="comment-delimiter">;; </span><span class="comment">number in the set.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span>
(<span class="keyword">defun</span> <span class="function-name">heptagonal-number</span> (n)
  <span class="doc">"Return n * (5 * n - 3) / 2. "</span>
  (/ (* n (- (* 5 n) 3)) 2))

(<span class="keyword">defun</span> <span class="function-name">heptagonal-number-p</span> (n)
  <span class="doc">"Test if N is Heptagonal number. "</span>
  (<span class="keyword">multiple-value-bind</span> (sqrtp sqrt)
      (integer-square-p (+ 9 (* 40 n)))
    (<span class="keyword">if</span> sqrtp
        (<span class="keyword">let</span> ((num (+ 3 sqrt)))
          (<span class="keyword">if</span> (modp num 10)
              (values t (/ num 10))
              (values nil nil)))
        (values nil nil))))

(<span class="keyword">defun</span> <span class="function-name">octagonal-number</span> (n)
  <span class="doc">"Return n * (3 * n - 2). "</span>
  (* n (- (* 3 n) 2)))

(<span class="keyword">defun</span> <span class="function-name">octagonal-number-p</span> (n)
  <span class="doc">"Test if N is Octagonal number. "</span>
  (<span class="keyword">multiple-value-bind</span> (sqrtp sqrt)
      (integer-square-p (1+ (* 3 n)))
    (<span class="keyword">if</span> sqrtp
        (<span class="keyword">let</span> ((num (1+ sqrt)))
          (<span class="keyword">if</span> (modp num 3)
              (values t   (/ num 3))
              (values nil nil)))
        (values nil nil))))

(<span class="keyword">defun</span> <span class="function-name">cyclic-digits-list-p</span> (list size <span class="type">&amp;optional</span> (base 10))
  <span class="doc">"Test if LIST is a list of Cyclic digits.
The SIZE is the Cyclic part size.

Example:

    (cyclic-digits-list-p '(8128 2882 8281) 2) ; =&gt; t
"</span>
  (<span class="keyword">loop</span> with 1st  = (p-digits (first list) base)
        with last = (int&lt;-p-digits (subseq 1st 0 size) base)
        with prev = (int&lt;-p-digits (last   1st size)   base)
        for elem in (rest list)
        for digit = (p-digits elem)
        for head = (int&lt;-p-digits (subseq digit 0 size) base)
        for tail = (int&lt;-p-digits (last   digit size)   base)
        if (not (= prev head))
          return nil
        do (setf prev tail)
        finally (<span class="keyword">return</span> (equal tail last))))

(<span class="keyword">defun</span> <span class="function-name">square-number</span> (n)
  <span class="doc">"Return n^2. "</span>
  (square n))

(<span class="keyword">defun</span> <span class="function-name">square-number-p</span> (n)
  <span class="doc">"Test if N is Square number. "</span>
  (integer-square-p n))

<span class="comment-delimiter">;; </span><span class="comment">Algorithm:
</span><span class="comment-delimiter">;; </span><span class="comment">for given PREV at i-th position, find the NEXT that
</span><span class="comment-delimiter">;; </span><span class="comment">satisfy (test i) that ((test i) (+ (* PREV 100) NEXT)).
</span><span class="comment-delimiter">;; </span><span class="comment">if satisfies, search next or otherwise, return nil.
</span>
(<span class="keyword">defun</span> <span class="function-name">problem61</span> (<span class="type">&amp;optional</span> (tests (list #'triangle-number-p
                                         #'square-number-p
                                         #'pentagonal-number-p
                                         #'hexagonal-number-p
                                         #'heptagonal-number-p
                                         #'octagonal-number-p))
                    (digits 2))
  <span class="doc">"Return the sum of cyclic 4-digit. "</span>
  (<span class="keyword">let</span> ((shift (expt 10 digits))
        (min   (expt 10 (1- digits)))
        (max   (1- (expt 10 digits))))
    (<span class="keyword">labels</span> ((iter (test rest prev tail)
               (<span class="keyword">if</span> (endp rest)
                   (<span class="keyword">let</span> ((num (+ (* prev shift) tail)))
                     (<span class="keyword">when</span> (funcall test num)
                       (list num)))
                   (<span class="keyword">loop</span> for next from min upto max
                         for num = (+ (* prev shift) next)
                         for seq = (<span class="keyword">when</span> (funcall test num)
                                     (iter (car rest) (cdr rest) next tail))
                         if seq return (cons num seq)))))
      (<span class="keyword">loop</span> for test-seq in (permutation-list tests) do
        (<span class="keyword">loop</span> for tail from min upto max
              for seq = (iter (car test-seq) (cdr test-seq) tail tail)
              if seq do (<span class="keyword">return-from</span> problem61 (values (sum seq) seq)))))))

<hr />
<span class="comment-delimiter">;;; </span><span class="comment">Problem 62. Cubic Permutations
</span><span class="comment-delimiter">;; </span><span class="comment">The cube, 41063625 (345^3), can be permuted to produce two other cubes:
</span><span class="comment-delimiter">;; </span><span class="comment">56623104 (384^3) and 66431025 (405^3). In fact, 41063625 is the smallest
</span><span class="comment-delimiter">;; </span><span class="comment">cube which has exactly three permutations of its digits which are also
</span><span class="comment-delimiter">;; </span><span class="comment">cube.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">Find the smallest cube for which exactly five permutations of its
</span><span class="comment-delimiter">;; </span><span class="comment">digits are cube.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span>
(<span class="keyword">defun</span> <span class="function-name">cube</span> (x)
  <span class="doc">"Return x^3. "</span>
  (* x (* x x)))

<span class="comment-delimiter">;; </span><span class="comment">Newton's method
</span><span class="comment-delimiter">;; </span><span class="comment">x = (2 * x + n / x^2) / 3
</span>
(<span class="keyword">defun</span> <span class="function-name">integer-cube-p</span> (x)
  <span class="doc">"Test if X is n^3. "</span>
  (<span class="keyword">loop</span> for x1 = x then x2
        for x2 = (truncate (+ (* 2 x1) (truncate x (* x1 x1))) 3)
        if (&gt;= x2 x1)
          return (<span class="keyword">if</span> (= (cube x1) x)
                     (values t   x1)
                     (values nil nil))))

(<span class="keyword">defun</span> <span class="function-name">problem62</span> (<span class="type">&amp;optional</span> (count 5))
  <span class="doc">"Find the smallest cube has COUNT permutations. "</span>
  (<span class="keyword">loop</span> with cnts = (make-hash-table <span class="builtin">:test</span> 'equal)
        for i from 1
        for cube = (cube i)
        for key  = (sort (p-digits cube) #'&lt;)
        for (val . cnt) = (or (gethash key cnts)
                              (cons cube 0))
        for cnt* = (1+ cnt)
        if (= cnt* count)
          return val
        do (setf (gethash key cnts) (cons val cnt*))))

<hr />
<span class="comment-delimiter">;;; </span><span class="comment">Problem 63. Powerful Digit Counts
</span><span class="comment-delimiter">;; </span><span class="comment">The 5-digit number, 16807 = 7^5, is also a fifth power. Similarly,
</span><span class="comment-delimiter">;; </span><span class="comment">the 9-digit number, 134217728 = 8^9, is a ninth power.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">How many n-digit positive integers exist which are also an nth power?
</span><span class="comment-delimiter">;;</span><span class="comment">
</span>
<span class="comment-delimiter">;;    </span><span class="comment">1 = 1^1
</span><span class="comment-delimiter">;;   </span><span class="comment">16 = 4^2
</span><span class="comment-delimiter">;;  </span><span class="comment">729 = 9^3
</span><span class="comment-delimiter">;; </span><span class="comment">6561 = 9^4
</span><span class="comment-delimiter">;;  </span><span class="comment">... = ...
</span><span class="comment-delimiter">;;</span><span class="comment">
</span>
(<span class="keyword">defun</span> <span class="function-name">problem63</span> ()
  <span class="doc">"Count n-digit positive integers as nth power. "</span>
  (<span class="keyword">loop</span> with count = 0
        with pattern = ()
        for n from 1
        while (<span class="keyword">loop</span> with modifiedp = nil
                    for base from 1
                    for num  = (expt base n)
                    for digits = (count-digits num)
                    if (= digits n)
                      do (push (list base n num digits) pattern)
                      and do (setf count (1+ count)
                                   modifiedp t)
                    if (&gt; digits n) <span class="comment">; if cannot find base more
</span>                      return modifiedp)
        finally (<span class="keyword">return</span> (values count pattern))))

<hr />
<span class="comment-delimiter">;;; </span><span class="comment">Problem 64. Odd Period Square Roots
</span><span class="comment-delimiter">;; </span><span class="comment">All square roots are periodic when written as continued fractions
</span><span class="comment-delimiter">;; </span><span class="comment">and can be written in the form:
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;;    </span><span class="comment">sqrt(N) = a0 + 1 / (a1 + 1 / (a2 + 1 / (a3 + ...)))
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">For example, let us consider sqrt(23):
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;;    </span><span class="comment">sqrt(23) = 4 + sqrt(23) - 4 = 4 + 1 / (1 / (sqrt(23) - 4))
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">The process can be summarised as follows:
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;;    </span><span class="comment">a0 = 4, 1 / (sqrt(23) - 4) =     (sqrt(23) + 4) /  7 = 1 + (sqrt(23) - 3) / 7
</span><span class="comment-delimiter">;;    </span><span class="comment">a1 = 1, 7 / (sqrt(23) - 3) = 7 * (sqrt(23) + 3) / 14 = 3 + (sqrt(23) - 3) / 2
</span><span class="comment-delimiter">;;    </span><span class="comment">a2 = 3, 2 / (sqrt(23) - 3) = 2 * (sqrt(23) + 3) / 14 = 1 + (sqrt(23) - 4) / 7
</span><span class="comment-delimiter">;;    </span><span class="comment">a3 = 1, 7 / (sqrt(23) - 4) = 7 * (sqrt(23) + 4) /  7 = 8 + (sqrt(23) - 4)
</span><span class="comment-delimiter">;;    </span><span class="comment">a4 = 8, 1 / (sqrt(23) - 4) =     (sqrt(23) + 4) /  7 = 1 + (sqrt(23) - 3) / 7
</span><span class="comment-delimiter">;;    </span><span class="comment">a5 = 1, 7 / (sqrt(23) - 3) = 7 * (sqrt(23) + 3) / 14 = 3 + (sqrt(23) - 3) / 2
</span><span class="comment-delimiter">;;    </span><span class="comment">a6 = 3, 7 / (sqrt(23) - 3) = 2 * (sqrt(23) + 3) / 14 = 1 + (sqrt(23) - 4) / 7
</span><span class="comment-delimiter">;;    </span><span class="comment">a7 = 1, 7 / (sqrt(23) - 4) = 7 * (sqrt(23) + 4) /  7 = 8 + (sqrt(23) - 4)
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">It can be seen that the sequence is repeating. For conciseness, we use
</span><span class="comment-delimiter">;; </span><span class="comment">the notation sqrt(23) = [4; (1, 2, 1, 8)], to indicate that the block
</span><span class="comment-delimiter">;; </span><span class="comment">(1, 3, 1, 8) repeats indefinitely.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">The first ten continued fraction representations of (irrational)
</span><span class="comment-delimiter">;; </span><span class="comment">square roots are:
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;;    </span><span class="comment">sqrt(2) = [1; (2)],             period = 1
</span><span class="comment-delimiter">;;    </span><span class="comment">sqrt(3) = [1; (1, 2)],          period = 2
</span><span class="comment-delimiter">;;    </span><span class="comment">sqrt(5) = [2; (4)],             period = 1
</span><span class="comment-delimiter">;;    </span><span class="comment">sqrt(6) = [2; (2, 4)],          period = 2
</span><span class="comment-delimiter">;;    </span><span class="comment">sqrt(7) = [2; (1, 1, 1, 4)],    period = 4
</span><span class="comment-delimiter">;;    </span><span class="comment">sqrt(8) = [2; (1, 4)],          period = 2
</span><span class="comment-delimiter">;;   </span><span class="comment">sqrt(10) = [3; (6)],             period = 1
</span><span class="comment-delimiter">;;   </span><span class="comment">sqrt(11) = [3; (3, 6)],          period = 2
</span><span class="comment-delimiter">;;   </span><span class="comment">sqrt(12) = [3; (2, 6)],          period = 2
</span><span class="comment-delimiter">;;   </span><span class="comment">sqrt(13) = [3; (1, 1, 1, 1, 6)], period = 5
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">Extract four continued fractions, for N &lt;= 13, have an odd period.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">How many continued fractions for N &lt;= 10000 have an odd period.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span>
<span class="comment-delimiter">;; </span><span class="comment">Notice that:
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;;    </span><span class="comment">a0 = truncate(sqrt(x))
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;;    </span><span class="comment">ni / (sqrt(x) - d)
</span><span class="comment-delimiter">;;    </span><span class="comment">= ni * (sqrt(x) + di) / (x - di^2) =&gt; (sqrt(x) + di) / D
</span><span class="comment-delimiter">;;    </span><span class="comment">= ai+1 + (sqrt(x) - di+1) / ni+1
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;;    </span><span class="comment">=&gt; ni+1 = (x - di^2) / ni
</span><span class="comment-delimiter">;;    </span><span class="comment">=&gt; ai+1 = truncate(ni / (sqrt(x) - di))
</span><span class="comment-delimiter">;;    </span><span class="comment">=&gt; di+1 = ai+1 * ni+1 - di
</span><span class="comment-delimiter">;;</span><span class="comment">
</span>
(<span class="keyword">defun</span> <span class="function-name">integer-sqrt-cycle</span> (x)
  <span class="doc">"Return a list of (a0 . (a1 a2 a3 ...)). "</span>
  (<span class="keyword">let</span> ((sqrt (sqrt x))
        (a0   (isqrt x)))
    (<span class="keyword">labels</span> ((iter (ai ni di ands)
               (<span class="keyword">let*</span> ((ni+1 (/ (- x (square di)) ni))
                      (ai+1 (truncate ni (- sqrt di)))
                      (di+1 (- (* ai+1 ni+1) di)))
                 (<span class="keyword">if</span> (find (list ai+1 ni+1 di+1) ands <span class="builtin">:test</span> #'equal)
                     (list ai)
                     (cons ai (iter ai+1 ni+1 di+1
                                    (cons (list ai+1 ni+1 di+1) ands)))))))
      (<span class="keyword">if</span> (= (square a0) x)
          (values () a0)
          (values (cdr (iter a0 1 a0 (list (list a0 1 a0)))) a0)))))

(<span class="keyword">defun</span> <span class="function-name">problem64</span> (<span class="type">&amp;optional</span> (max 10000))
  <span class="doc">"Count odd period fractions upto MAX. "</span>
  (<span class="keyword">loop</span> for n below max
        count (oddp (length (integer-sqrt-cycle n)))))

<hr />
<span class="comment-delimiter">;;; </span><span class="comment">Problem 65. Convergents of e
</span><span class="comment-delimiter">;; </span><span class="comment">The square root of 2 can be written as an infinite continued fraction.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;;     </span><span class="comment">sqrt(2) = 1 + 1 / (2 + 1 / (2 + 1 / ...))
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">The infinite continued fraction can be written, sqrt(2) = [1; (2)],
</span><span class="comment-delimiter">;; </span><span class="comment">(2) indicates that 2 repeats ad infinitum. In a similar way,
</span><span class="comment-delimiter">;; </span><span class="comment">sqrt(23) = [4; (1, 3, 1, 8)].
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">It turns out that the sequence of partial values of continued fractions
</span><span class="comment-delimiter">;; </span><span class="comment">for square roots provide the best rational approximations. Let us
</span><span class="comment-delimiter">;; </span><span class="comment">consider the convergents for sqrt(2).
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;;    </span><span class="comment">1 + 1/2                               = 3/2
</span><span class="comment-delimiter">;;    </span><span class="comment">1 + 1 / (2 + 1/2)                     = 7/5
</span><span class="comment-delimiter">;;    </span><span class="comment">1 + 1 / (2 + 1 / (2 + 1/2))           = 17/12
</span><span class="comment-delimiter">;;    </span><span class="comment">1 + 1 / (2 + 1 / (2 + 1 / (2 + 1/2))) = 41/29
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">Hence the sequence of the first ten convergents for sqrt(2) are:
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;;    </span><span class="comment">1, 3/2, 7/5, 41/29, 99/70, 239/169, 577/408, 1393/985, 3363/2378, ...
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">What is most surprising is that the important mathematical constant,
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;;    </span><span class="comment">e = [2; 1, 2, 1, 1, 4, 1, 1, 6, 1, ..., 2 * k, 1, ...]
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">The first ten terms in the sequence of convergents for e are:
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;;    </span><span class="comment">2, 3, 8/3, 11/4, 19/7, 87/32, 106/39, 193/71, 1264/465, 1457/536, ...
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">The sum of digits in the numerator of the 10th convergent is 1 + 4 + 5 + 7 = 17.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">Find the sum of digits in the numerator of 100th convergent of the
</span><span class="comment-delimiter">;; </span><span class="comment">continued fraction for e.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span>
(<span class="keyword">defun</span> <span class="function-name">convergents&lt;-regular-continued-fraction1</span> (int fractions)
  <span class="doc">"Turn [n, (fractions)] into a convergent value.

Example:

    sqrt(2) = (... 1 '(2 2 2))
            = 1 + 1/(2 + 1/(2 + 1/(2)))
"</span>
  (<span class="keyword">labels</span> ((unfold (fractions)
             (<span class="keyword">if</span> (endp fractions) 0
                 (/ (+ (car fractions) (unfold (cdr fractions)))))))
    (+ int (unfold fractions))))

(<span class="keyword">defun</span> <span class="function-name">problem65</span> (<span class="type">&amp;optional</span> (nth 100))
  <span class="doc">"Return the sum of digits of NTH numerator convergent of e. "</span>
  (funcall (compose (compose #'sum #'p-digits) #'numerator)
           (convergents&lt;-regular-continued-fraction1
            2
            (<span class="keyword">loop</span> with k = 0
                  with i = 1
                  for cnt from 1 below nth
                  if (zerop i)
                    collect (* 2 (incf k))
                    and do (setf i 2)
                  else
                    collect 1
                    and do (decf i)))))

<hr />
<span class="comment-delimiter">;;; </span><span class="comment">Problem 66. Diophantine Equation
</span><span class="comment-delimiter">;; </span><span class="comment">Consider quadratic Diophantine equations of the form:
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;;    </span><span class="comment">x^2 - D * y^2 = 1
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">For example, when D = 13, the minimal solution in x is
</span><span class="comment-delimiter">;; </span><span class="comment">649^2 - 13 * 180^2 = 1.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">It can be assumed that there are no solutions in positive
</span><span class="comment-delimiter">;; </span><span class="comment">integers when D is square.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">By finding minimal solutions in x for D = {2, 3, 5, 6, 7},
</span><span class="comment-delimiter">;; </span><span class="comment">we obtain the following:
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;;    </span><span class="comment">3^2 - 2 * 2^2 = 1
</span><span class="comment-delimiter">;;    </span><span class="comment">2^2 - 3 * 1^2 = 1
</span><span class="comment-delimiter">;;    </span><span class="comment">9^2 - 5 * 4^2 = 1
</span><span class="comment-delimiter">;;    </span><span class="comment">5^2 - 6 * 2^2 = 1
</span><span class="comment-delimiter">;;    </span><span class="comment">8^2 - 7 * 3^2 = 1
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">Hence, by considering minimal solutions in x for D &lt;= 7,
</span><span class="comment-delimiter">;; </span><span class="comment">the largest x is obtained when D = 5.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">Find the value of D &lt;= 1000 in minimal solutions of x for
</span><span class="comment-delimiter">;; </span><span class="comment">which the largest value of x is obtained.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span>
<span class="comment-delimiter">;; </span><span class="comment">Pell's Equation
</span><span class="comment-delimiter">;; </span><span class="comment">see https://en.wikipedia.org/wiki/Pell%27s_equation
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">this is much faster than counting directly
</span>
(<span class="keyword">defun</span> <span class="function-name">pells-equation-fundamental-solution</span> (d)
  <span class="doc">"Find the minimal root of x^2 - D * y^2 = 1. "</span>
  (<span class="keyword">multiple-value-bind</span> (fractions int)
      (integer-sqrt-cycle d)
    (<span class="keyword">when</span> fractions
      (<span class="keyword">let</span> ((conv (<span class="keyword">if</span> (evenp (length fractions))
                      (convergents&lt;-regular-continued-fraction1
                       int (butlast fractions))
                      (convergents&lt;-regular-continued-fraction1
                       int (append fractions (butlast fractions))))))
        (values (numerator conv) (denominator conv))))))

(<span class="keyword">defun</span> <span class="function-name">problem66</span> (<span class="type">&amp;optional</span> (dmax 1000))
  <span class="doc">"Return the max of `</span><span class="doc"><span class="constant">find-min-x^2-d*y^2=1</span></span><span class="doc">' result x. "</span>
  (<span class="keyword">loop</span> with max = 0
        with max-d = 0
        for d from 1 upto dmax
        for x = (pells-equation-fundamental-solution d)
        do (print (list d x))
        if (and x (&lt; max x))
          do (setf max   x
                   max-d d)
        finally (<span class="keyword">return</span> max-d)))

<hr />
<span class="comment-delimiter">;;; </span><span class="comment">Problem 67. Maximum Path Sum II
</span><span class="comment-delimiter">;; </span><span class="comment">see Problem 18.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span>
(<span class="keyword">defun</span> <span class="function-name">problem67</span> ()
  <span class="doc">"see problem 18. "</span>
  (problem18 (read-file <span class="string">"./dat/0067_triangle.sexp"</span>)))

<hr />
<span class="comment-delimiter">;;; </span><span class="comment">Problem 68. Magic 5-gon Ring
</span><span class="comment-delimiter">;; </span><span class="comment">Consider the following "magic" 3-gon ring, filled with the numbers 1 to 6,
</span><span class="comment-delimiter">;; </span><span class="comment">and each line adding to nine.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;;          </span><span class="comment">4                         0
</span><span class="comment-delimiter">;;            </span><span class="comment">\                         \
</span><span class="comment-delimiter">;;             </span><span class="comment">3                         2
</span><span class="comment-delimiter">;;            </span><span class="comment">/  \                      /  \
</span><span class="comment-delimiter">;;           </span><span class="comment">1 -- 2 -- 6               1 -- 0 -- 1
</span><span class="comment-delimiter">;;          </span><span class="comment">/                         /
</span><span class="comment-delimiter">;;        </span><span class="comment">5                         2
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">Working clockwise, and starting from the group of three with the
</span><span class="comment-delimiter">;; </span><span class="comment">numerically lowest external node (4, 3, 2, in this example),
</span><span class="comment-delimiter">;; </span><span class="comment">each solution can be described uniquely. For example, the above
</span><span class="comment-delimiter">;; </span><span class="comment">solution can be described by the set: 4,3,2; 6,2,1; 5,1,3.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">It is possible to complete the ring with four different totals:
</span><span class="comment-delimiter">;; </span><span class="comment">9, 10, 11, and 12. There are eight solutions in total.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;;     </span><span class="comment">Total            Solution Set
</span><span class="comment-delimiter">;;       </span><span class="comment">9            4,2,3; 5,3,1; 6,1,2
</span><span class="comment-delimiter">;;       </span><span class="comment">9            4,3,2; 6,2,1; 5,1,3
</span><span class="comment-delimiter">;;      </span><span class="comment">10            2,3,5; 4,5,1; 6,1,3
</span><span class="comment-delimiter">;;      </span><span class="comment">10            2,5,3; 6,3,1; 4,1,5
</span><span class="comment-delimiter">;;      </span><span class="comment">11            1,4,6; 3,6,2; 5,2,4
</span><span class="comment-delimiter">;;      </span><span class="comment">11            1,6,4; 5,4,2; 3,2,6
</span><span class="comment-delimiter">;;      </span><span class="comment">12            1,5,6; 2,6,4; 3,4,5
</span><span class="comment-delimiter">;;      </span><span class="comment">12            1,6,5; 3,5,4; 2,4,6
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">By concatenating each group it is possible to form 9-digit strings;
</span><span class="comment-delimiter">;; </span><span class="comment">the maximum string for a 3-gon ring is 432621513.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">Using the numbers 1 to 10, and depending on arrangements, it
</span><span class="comment-delimiter">;; </span><span class="comment">is possible to form 16-and 17-digit strings. What is the maximum
</span><span class="comment-delimiter">;; </span><span class="comment">16-digit string for a "magic" 5-gon ring?
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;;           </span><span class="comment">()
</span><span class="comment-delimiter">;;             </span><span class="comment">\
</span><span class="comment-delimiter">;;              </span><span class="comment">()  ()
</span><span class="comment-delimiter">;;             </span><span class="comment">/  \ |
</span><span class="comment-delimiter">;;           </span><span class="comment">()     ()
</span><span class="comment-delimiter">;;          </span><span class="comment">/ |     |
</span><span class="comment-delimiter">;;        </span><span class="comment">() () --- () -- ()
</span><span class="comment-delimiter">;;            </span><span class="comment">|
</span><span class="comment-delimiter">;;           </span><span class="comment">()
</span><span class="comment-delimiter">;;</span><span class="comment">
</span>
(<span class="keyword">defstruct</span> <span class="type">n-gon-ring</span>
  (min   1  <span class="builtin">:type</span> (integer 0))
  (max   10 <span class="builtin">:type</span> (integer 0))
  (n     3  <span class="builtin">:type</span> (integer 3))
  (inner (make-array 3 <span class="builtin">:initial-element</span> 0
                       <span class="builtin">:element-type</span>    'integer)
   <span class="builtin">:type</span> array)
  (outter (make-array 3 <span class="builtin">:initial-element</span> 0
                        <span class="builtin">:element-type</span>    'integer)
   <span class="builtin">:type</span> array))

(<span class="keyword">defun</span> <span class="function-name">n-gon-ring</span> (n <span class="type">&amp;key</span> (min 1) (max 10) (initial-contents () initial-contents-p))
  <span class="doc">"Make magick N gon ring. "</span>
  (<span class="keyword">let*</span> ((inner  (make-array n <span class="builtin">:initial-element</span> -1
                               <span class="builtin">:element-type</span>    'integer))
         (outter (make-array n <span class="builtin">:initial-element</span> -1
                               <span class="builtin">:element-type</span>    'integer))
         (ring   (make-n-gon-ring <span class="builtin">:min</span>    min
                                  <span class="builtin">:max</span>    max
                                  <span class="builtin">:n</span>      n
                                  <span class="builtin">:inner</span>  inner
                                  <span class="builtin">:outter</span> outter)))
    <span class="comment-delimiter">;;                                     </span><span class="comment">r1
</span>    <span class="comment-delimiter">;;          </span><span class="comment">4                         0
</span>    <span class="comment-delimiter">;;            </span><span class="comment">\                         \ r2
</span>    <span class="comment-delimiter">;;             </span><span class="comment">3                         2       -----------+
</span>    <span class="comment-delimiter">;;            </span><span class="comment">/  \                      /  \ r3             |
</span>    <span class="comment-delimiter">;;           </span><span class="comment">1 -- 2 -- 6               1 -- 0 -- 1          |
</span>    <span class="comment-delimiter">;;          </span><span class="comment">/                         / R3   R2   R1  &lt;-----+
</span>    <span class="comment-delimiter">;;        </span><span class="comment">5                         2
</span>    (<span class="keyword">when</span> initial-contents-p
      (<span class="warning">assert</span> (= n (length initial-contents)))
      (<span class="keyword">loop</span> for i0 from 0
            for i1 = i0
            for i2 = (mod (1- i0) n)
            for i3 = (mod i0      n)
            for (r1 r2 r3) in initial-contents
            do (setf (aref outter i1) r1)
            do (<span class="keyword">if</span> (= -1 (aref inner i2))
                   (setf (aref inner i2) r2)
                   (<span class="warning">assert</span> (= r2 (aref inner i2))))
            do (<span class="keyword">if</span> (= -1 (aref inner i3))
                   (setf (aref inner i3) r3)
                   (<span class="warning">assert</span> (= r3 (aref inner i3))))))
    ring))

(<span class="keyword">defmethod</span> <span class="function-name">print-object</span> ((ring n-gon-ring) stream)
  (print-unreadable-object (ring stream)
    (<span class="keyword">let</span> ((inner  (n-gon-ring-inner  ring))
          (outter (n-gon-ring-outter ring))
          (n      (n-gon-ring-n      ring)))
      (format stream <span class="string">"~D gon ring: "</span> n)
      (<span class="keyword">loop</span> for i0 from 0 below n
            for i1 = i0
            for i2 = (mod (1- i0) n)
            for i3 = (mod i0      n)
            for r1 = (aref outter i1)
            for r2 = (aref inner  i2)
            for r3 = (aref inner  i3)
            do (format stream <span class="string">"~D,~D,~D; "</span> r1 r2 r3)))))

(<span class="keyword">defun</span> <span class="function-name">n-gon-ring&lt;-string</span> (string)
  <span class="doc">"Turn STRING into n-gon-ring. "</span>
  (<span class="keyword">let</span> ((contents (mapcar (compose (curry #'mapcar #'parse-integer)
                                   (curry #'str:split-omit-nulls <span class="string">","</span>))
                          (str:split-omit-nulls <span class="string">";"</span> string))))
    (<span class="warning">assert</span> (mapcar (compose (curry #'= 3) #'length) contents))
    (n-gon-ring (length contents) <span class="builtin">:initial-contents</span> contents)))

(<span class="keyword">defun</span> <span class="function-name">list&lt;-n-gon-ring</span> (ring)
  <span class="doc">"Turn RING into list. "</span>
  (<span class="keyword">let</span> ((inner  (n-gon-ring-inner  ring))
        (outter (n-gon-ring-outter ring))
        (n      (n-gon-ring-n      ring)))
    (<span class="keyword">loop</span> for i0 from 0 below n
          for i1 = i0
          for i2 = (mod (1- i0) n)
          for i3 = (mod i0      n)
          for r1 = (aref outter i1)
          for r2 = (aref inner  i2)
          for r3 = (aref inner  i3)
          collect (list r1 r2 r3))))

(<span class="keyword">defun</span> <span class="function-name">copy-n-gon-ring</span> (ring)
  <span class="doc">"Copy RING. "</span>
  (n-gon-ring (n-gon-ring-n ring)
              <span class="builtin">:min</span> (n-gon-ring-min ring)
              <span class="builtin">:max</span> (n-gon-ring-max ring)
              <span class="builtin">:initial-contents</span> (list&lt;-n-gon-ring ring)))

(<span class="keyword">defun</span> <span class="function-name">n-gon-ring=</span> (ring1 ring2)
  <span class="doc">"Test if RING1 is equal to RING2. "</span>
  (<span class="keyword">let</span> ((n1 (n-gon-ring-n ring1))
        (n2 (n-gon-ring-n ring2)))
    (<span class="keyword">when</span> (= n1 n2)
      (<span class="keyword">let</span> ((inner1  (n-gon-ring-inner  ring1))
            (inner2  (n-gon-ring-inner  ring2))
            (outter1 (n-gon-ring-outter ring1))
            (outter2 (n-gon-ring-outter ring2)))
        <span class="comment-delimiter">;;                                     </span><span class="comment">r1
</span>        <span class="comment-delimiter">;;          </span><span class="comment">4                         0
</span>        <span class="comment-delimiter">;;            </span><span class="comment">\                         \ r2
</span>        <span class="comment-delimiter">;;             </span><span class="comment">3                   r3*   2       -----------+
</span>        <span class="comment-delimiter">;;            </span><span class="comment">/  \                      /  \ r3             |
</span>        <span class="comment-delimiter">;;           </span><span class="comment">1 -- 2 -- 6        r2*    1 -- 0 -- 1          |
</span>        <span class="comment-delimiter">;;          </span><span class="comment">/                         / R3   R2   R1  &lt;-----+
</span>        <span class="comment-delimiter">;;        </span><span class="comment">5                   r1*    2
</span>        (<span class="keyword">loop</span> with n = n1
              for offset from 0 below n
              if (and-repeat (i n)
                   (<span class="keyword">let</span> ((i3 i)               (i3* (mod (+ i      offset) n))
                         (i2 (mod (1- i) n))  (i2* (mod (+ (1- i) offset) n))
                         (i1 i)               (i1* (mod (+ i      offset) n)))
                     (and (= (aref inner1  i3) (aref inner2  i3*))
                          (= (aref inner1  i2) (aref inner2  i2*))
                          (= (aref outter1 i1) (aref outter2 i1*)))))
                return t)))))

(<span class="keyword">defun</span> <span class="function-name">subtract-list</span> (list1 list2 <span class="type">&amp;optional</span> key test)
  <span class="doc">"Return a list with elements in LIST1 but not in LIST2. "</span>
  (remove-if (rcurry* #'find list2 <span class="builtin">:key</span> key <span class="builtin">:test</span> test) list1))

<span class="comment-delimiter">;; </span><span class="comment">Algorithm:
</span><span class="comment-delimiter">;; </span><span class="comment">0. let all the possible choices list as PICKS
</span><span class="comment-delimiter">;;    </span><span class="comment">pick 3 elements from PICKS and remove them from PICKS
</span><span class="comment-delimiter">;;    </span><span class="comment">set the 3 elements to the first row (r1, r2, r3)
</span><span class="comment-delimiter">;;    </span><span class="comment">let TOTAL = sum(3 elements)
</span><span class="comment-delimiter">;; </span><span class="comment">1. for second row:
</span><span class="comment-delimiter">;;    </span><span class="comment">pick one from PICKS as R3
</span><span class="comment-delimiter">;;    </span><span class="comment">the R2 is determinated from previous row
</span><span class="comment-delimiter">;;    </span><span class="comment">calculate R1 = TOTAL - R2 - R3
</span><span class="comment-delimiter">;;    </span><span class="comment">if R1 is within PICKS, stop (failed search)
</span><span class="comment-delimiter">;;    </span><span class="comment">otherwise, repeat process for next row (third row)
</span><span class="comment-delimiter">;; </span><span class="comment">2. if find a new, collect them
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">emmm, is it's like filling sudoku?
</span><span class="comment-delimiter">;;</span><span class="comment">
</span>
(<span class="keyword">defun</span> <span class="function-name">try-fill-ring</span> (n <span class="type">&amp;key</span> (min 1) (max 10))
  <span class="doc">"Try to fill the N gon ring.
Return a list of all the possible ring. "</span>
  (<span class="keyword">declare</span> (type (integer 3) n))
  (<span class="keyword">let*</span> ((ring   (n-gon-ring n <span class="builtin">:min</span> min <span class="builtin">:max</span> max))
         (inner  (n-gon-ring-inner  ring))
         (outter (n-gon-ring-outter ring))
         (result ()))
    <span class="comment-delimiter">;;                                     </span><span class="comment">r1
</span>    <span class="comment-delimiter">;;          </span><span class="comment">4                         0
</span>    <span class="comment-delimiter">;;            </span><span class="comment">\                         \ r2
</span>    <span class="comment-delimiter">;;             </span><span class="comment">3                   r3*   2       -----------+
</span>    <span class="comment-delimiter">;;            </span><span class="comment">/  \                      /  \ r3             |
</span>    <span class="comment-delimiter">;;           </span><span class="comment">1 -- 2 -- 6        r2*    1 -- 0 -- 1          |
</span>    <span class="comment-delimiter">;;          </span><span class="comment">/                         / R3   R2   R1  &lt;-----+
</span>    <span class="comment-delimiter">;;        </span><span class="comment">5                   r1*    2
</span>    (<span class="keyword">labels</span> ((iter (total i3 picks)
               (<span class="keyword">if</span> (= i3 (1- n))
                   <span class="comment-delimiter">;; </span><span class="comment">for the last row in ring,
</span>                   <span class="comment-delimiter">;; </span><span class="comment">r2*, r3* is setted before, r1* is determined by:
</span>                   <span class="comment-delimiter">;; </span><span class="comment">r1* = total - r2* - r3*
</span>                   (<span class="keyword">let*</span> ((i2 (mod (1- i3) n))
                          (i1 i3)
                          (r2 (aref inner i2))
                          (r3 (aref inner i3))
                          (r1 (- total r2 r3)))
                     <span class="comment-delimiter">;; </span><span class="comment">If R1 is pickable from PICKS,
</span>                     <span class="comment-delimiter">;; </span><span class="comment">collect TOTAL and RING
</span>                     (<span class="keyword">when</span> (find r1 picks)
                       (setf (aref outter i1) r1)
                       (push (cons total (copy-n-gon-ring ring)) result)))
                   <span class="comment-delimiter">;; </span><span class="comment">for the row (not the last) in ring
</span>                   <span class="comment-delimiter">;; </span><span class="comment">R2 is setted before,
</span>                   <span class="comment-delimiter">;; </span><span class="comment">pick one R3 from PICKS,
</span>                   <span class="comment-delimiter">;; </span><span class="comment">R1 = total - R2 - R3
</span>                   <span class="comment-delimiter">;; </span><span class="comment">if R1 is found in PICKS,
</span>                   <span class="comment-delimiter">;; </span><span class="comment">search next row
</span>                   <span class="comment-delimiter">;; </span><span class="comment">otherwise, try next R2
</span>                   (<span class="keyword">loop</span> with i2 = (mod (1- i3) n)
                         with i1 = i3
                         with r2 = (aref inner i2)
                         for unfold = () then (cons r3 unfold)
                         for (r3 . folded) on picks
                         for r1 = (- total r2 r3)
                         if (find r1 unfold)
                           do (setf (aref inner  i3) r3
                                    (aref outter i1) r1)
                           and do (iter total (1+ i3) (append (remove r1 unfold)
                                                              folded))
                         if (find r1 folded)
                           do (setf (aref inner  i3) r3
                                    (aref outter i1) r1)
                           and do (iter total (1+ i3) (append (remove r1 folded)
                                                              unfold))))))
      <span class="comment-delimiter">;; </span><span class="comment">Set specific initial n gon ring
</span>      (<span class="keyword">loop</span> with choices = (range-list min max)
            for 1st-row in (n-pick-list choices 3)
            for picks = (subtract-list choices 1st-row)
            do (<span class="keyword">loop</span> for (r1 r2 r3) in (permutation-list 1st-row)
                     do (setf (aref outter 0)      r1)
                     do (setf (aref inner  (1- n)) r2)
                     do (setf (aref inner  0)      r3)
                     do (iter (+ r1 r2 r3) 1 picks)))
      (group result <span class="builtin">:key</span> #'car
                    <span class="builtin">:reduce</span> (<span class="keyword">lambda</span> (new collects)
                              (<span class="keyword">if</span> (find-if (curry #'n-gon-ring= (cdr new)) collects)
                                  collects
                                  (cons (cdr new) collects)))
                    <span class="builtin">:initial-value</span> ()))))

(<span class="keyword">defun</span> <span class="function-name">clockwise-string&lt;-n-gon-ring</span> (ring)
  <span class="doc">"Turn RING into clockwise string. "</span>
  (<span class="keyword">with-output-to-string</span> (str)
    (<span class="keyword">loop</span> with i1-min = 0 with r1-min = -1
          with n      = (n-gon-ring-n      ring)
          with inner  = (n-gon-ring-inner  ring)
          with outter = (n-gon-ring-outter ring)
          for i1 from 0 below n
          for r1 = (aref outter i1)
          if (or (= r1-min -1) (&lt; r1 r1-min))
            do (setf i1-min i1
                     r1-min r1)
          finally (<span class="keyword">loop</span> repeat n
                        for i1 = i1-min then (mod (1+ i1) n)
                        for i2 = (mod (1- i1) n)
                        for i3 = i1
                        collect (format str <span class="string">"~D~D~D"</span>
                                        (aref outter i1)
                                        (aref inner  i2)
                                        (aref inner  i3))))))

(<span class="keyword">defun</span> <span class="function-name">problem68</span> ()
  <span class="doc">"Return the maxim 16-digit string. "</span>
  (<span class="keyword">loop</span> with max = <span class="string">""</span>
        for ring in (apply #'append (mapcar #'cdr (try-fill-ring 5 <span class="builtin">:min</span> 1 <span class="builtin">:max</span> 10)))
        for digits = (clockwise-string&lt;-n-gon-ring ring)
        if (and (= 16 (length digits)) (string&lt; max digits))
          do (setf max digits)
        finally (<span class="keyword">return</span> max)))

<hr />
<span class="comment-delimiter">;;; </span><span class="comment">Problem 69. Totient Maximum
</span><span class="comment-delimiter">;; </span><span class="comment">Euler's totient function, phi(n) [sometimes called the phi function],
</span><span class="comment-delimiter">;; </span><span class="comment">is defined as the number of positive integers not exceeding n which
</span><span class="comment-delimiter">;; </span><span class="comment">are relatively prime to n. For example, as 1, 2, 4, 5, 7, and 8, are
</span><span class="comment-delimiter">;; </span><span class="comment">all less than or equal to nine and relatively prime to nine, phi(9) = 6.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;;     </span><span class="comment">|  n | Relatively Prime | phi(n) | n / phi(n) |
</span><span class="comment-delimiter">;;     </span><span class="comment">|----+------------------+--------+------------|
</span><span class="comment-delimiter">;;     </span><span class="comment">|  2 |        1         |   1    |     2      |
</span><span class="comment-delimiter">;;     </span><span class="comment">|  3 |      1, 2        |   2    |    1.5     |
</span><span class="comment-delimiter">;;     </span><span class="comment">|  4 |      1, 3        |   2    |     2      |
</span><span class="comment-delimiter">;;     </span><span class="comment">|  5 |    1, 2, 3, 4    |   4    |   1.25     |
</span><span class="comment-delimiter">;;     </span><span class="comment">|  6 |      1, 5        |   2    |     3      |
</span><span class="comment-delimiter">;;     </span><span class="comment">|  7 | 1, 2, 3, 4, 5, 6 |   6    |  1.1666... |
</span><span class="comment-delimiter">;;     </span><span class="comment">|  8 |    1, 3, 5, 7    |   4    |     2      |
</span><span class="comment-delimiter">;;     </span><span class="comment">|  9 | 1, 2, 4, 5, 7, 8 |   6    |    1.5     |
</span><span class="comment-delimiter">;;     </span><span class="comment">| 10 |    1, 3, 7, 9    |   4    |    2.5     |
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">It can be seen that n = 6 produces a maximum n / phi(n) for n &lt;= 10.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">Find the value of n &lt;= 1000000 for which n / phi(n) is a maximum.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span>
<span class="comment-delimiter">;; </span><span class="comment">Notice that:
</span><span class="comment-delimiter">;; </span><span class="comment">phi(n) = prod(pi^(ni-1))
</span><span class="comment-delimiter">;; </span><span class="comment">phi(n * m) = phi(n) * phi(m)
</span><span class="comment-delimiter">;; </span><span class="comment">phi(p) = p - 1
</span>
(defun-cached totient-function (n)
  <span class="string">"Return phi(n). "</span>
  (<span class="keyword">cond</span> ((= n 1)    1)
        ((primep n) (1- n))
        (t (<span class="keyword">loop</span> for m from (isqrt n) downto 2
                 if (modp n m)
                   return (* (totient-function m)
                             (totient-function (/ n m)))))))

(<span class="keyword">defun</span> <span class="function-name">problem69</span> (<span class="type">&amp;optional</span> (max 1000000))
  <span class="doc">"Find maximum of n / phi(n) for n upto MAX. "</span>
  (<span class="keyword">loop</span> with nmax = 0
        with vmax = 0
        for n from 1 upto max
        for v = (/ n (totient-function n))
        if (&gt; v vmax)
          do (setf nmax n
                   vmax v)
        finally (<span class="keyword">return</span> nmax)))

<hr />
<span class="comment-delimiter">;;; </span><span class="comment">Problem 70. Totient Permutation
</span><span class="comment-delimiter">;; </span><span class="comment">Euler's totient function, phi(n), is used to determine the number of
</span><span class="comment-delimiter">;; </span><span class="comment">positive numbers less than or equal to n which are relatively prime
</span><span class="comment-delimiter">;; </span><span class="comment">to n. For example, as 1, 2, 4, 5, 7, and 8, are all less than nine
</span><span class="comment-delimiter">;; </span><span class="comment">and relatively prime to nine, phi(9) = 6.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">The number 1 is considered to be relatively prime to every positive
</span><span class="comment-delimiter">;; </span><span class="comment">number, so phi(1) = 1.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">Interestingly, phi(87109) = 79180, and it can be seen that 87109
</span><span class="comment-delimiter">;; </span><span class="comment">is a permutation of 79180.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span><span class="comment-delimiter">;; </span><span class="comment">Find the value of n, 1 &lt; n &lt; 10^7, for which phi(n) is a permutaion
</span><span class="comment-delimiter">;; </span><span class="comment">of n and the ratio n / phi(n) produces a minimum.
</span><span class="comment-delimiter">;;</span><span class="comment">
</span>
<span class="comment-delimiter">;; </span><span class="comment">it is slow... (but adding some cache on the totient function,
</span><span class="comment-delimiter">;; </span><span class="comment">would make it less painful when you redo the problem).
</span>
(<span class="keyword">defun</span> <span class="function-name">problem70</span> (<span class="type">&amp;optional</span> (max (expt 10 7)))
  <span class="doc">"Find the n that produce maximum n/phi(n) and permutable phi(n). "</span>
  (<span class="keyword">loop</span> with nmin = 0
        with vmin = -1
        for n from 2 below max
        for phi = (totient-function n)
        for v = (/ n phi)
        if (and (p-digits-permutate-p phi n)
                (or (= -1 vmin) (&lt; v vmin)))
          do (setf vmin v
                   nmin n)
        finally (<span class="keyword">return</span> nmin)))

<span class="comment-delimiter">;;;; </span><span class="comment">euler100.lisp ends here
</span></pre>
  </body>
</html>
